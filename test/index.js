'use strict';

const NextModel = require('../lib');
const expect = require('expect.js');

const {
  map,
} = require('lodash');

describe('NextModel', function() {
  // Static properties
  // - must be inherited
  describe('.modelName', function() {
    subject(() => $Klass.modelName);

    context('when modelName is present', function() {
      def('Klass', () => class Klass extends NextModel {
        static get modelName() {
          return 'foo';
        }
      });

      it('returns the name of the model', function() {
        expect($subject).to.eql('foo');
      });
    });

    context('when modelName is not present', function() {
      def('Klass', () => class Klass extends NextModel {});

      it('throws error if modelName is not overwritten', function() {
        expect(() => $subject).to.throwError();
      });
    });
  });

  describe('.schema', function() {
    subject(() => $Klass.schema);

    context('when schema is present', function() {
      def('Klass', () => class Klass extends NextModel {
        static get schema() {
          return {};
        }
      });

      it('returns the schema of the model', function() {
        expect($subject).to.eql({});
      });
    });

    context('when schema is not present', function() {
      def('Klass', () => class Klass extends NextModel {});

      it('throws error if schema is not overwritten', function() {
        expect(() => $subject).to.throwError();
      });
    });
  });

  describe('.connector', function() {
    subject(() => $Klass.connector);

    context('when connector is present', function() {
      def('Klass', () => class Klass extends NextModel {
        static get connector() {
          return 'foo';
        }
      });

      it('returns the connector', function() {
        expect($subject).to.eql('foo');
      });
    });

    context('when connector is not present', function() {
      def('Klass', () => class Klass extends NextModel {});

      it('throws error if connector is not overwritten', function() {
        expect(() => $subject).to.throwError();
      });
    });
  });

  // - optional
  describe('.identifier', function() {
    subject(() => $Klass.identifier);

    context('when value is not overwritten', function() {
      def('Klass', () => class Klass extends NextModel {});

      it('returns default value', function() {
        expect($subject).to.eql('id');
      });
    });
  });

  describe('.tableName', function() {
    subject(() => $Klass.tableName);

    context('when tableName is present', function() {
      def('Klass', () => class Klass extends NextModel {
        static get tableName() {
          return 'foo';
        }
      });

      it('returns the name of the table', function() {
        expect($subject).to.eql('foo');
      });
    });

    context('when modelName is present', function() {
      def('Klass', () => class Klass extends NextModel {
        static get modelName() {
          return 'foo';
        }
      });

      it('returns the plural name of the model', function() {
        expect($subject).to.eql('foos');
      });
    });

    context('when modelName is not present', function() {
      def('Klass', () => class Klass extends NextModel {});

      it('throws error if modelName is not overwritten', function() {
        expect(() => $subject).to.throwError();
      });
    });

    context('when connector is present', function() {
      def('connector', () => ({ tableName: () => 'foo' }));
      def('Klass', () => class Klass extends NextModel {
        static get connector() {
          return $connector;
        }

        static get modelName() {
          return 'Klass';
        }
      });

      it('return tableName generated by connector', function() {
        expect($subject).to.eql('foo');
      });

      context('when connector does not provide tableName function', function() {
        def('connector', () => ({ }));

        it('falls back to camelcase', function() {
          expect($subject).to.eql('klasses');
        });
      });
    });
  });

  describe('.attrAccessors', function() {
    subject(() => $Klass.attrAccessors);

    context('when value is not overwritten', function() {
      def('Klass', () => class Klass extends NextModel {});

      it('returns default value', function() {
        expect($subject).to.eql([]);
      });
    });
  });

  describe('.belongsTo', function() {
    subject(() => $Klass.belongsTo);

    context('when value is not overwritten', function() {
      def('Klass', () => class Klass extends NextModel {});

      it('returns default value', function() {
        expect($subject).to.eql({});
      });
    });
  });

  describe('.hasMany', function() {
    subject(() => $Klass.hasMany);

    context('when value is not overwritten', function() {
      def('Klass', () => class Klass extends NextModel {});

      it('returns default value', function() {
        expect($subject).to.eql({});
      });
    });
  });

  describe('.hasOne', function() {
    subject(() => $Klass.hasOne);

    context('when value is not overwritten', function() {
      def('Klass', () => class Klass extends NextModel {});

      it('returns default value', function() {
        expect($subject).to.eql({});
      });
    });
  });

  describe('.useCache', function() {
    subject(() => $Klass.useCache);

    context('when value is not overwritten', function() {
      def('Klass', () => class Klass extends NextModel {});

      it('returns default value', function() {
        expect($subject).to.eql(true);
      });
    });
  });

  describe('.cacheData', function() {
    subject(() => $Klass.cacheData);

    context('when value is not overwritten', function() {
      def('Klass', () => class Klass extends NextModel {});

      it('returns default value', function() {
        expect($subject).to.eql(true);
      });
    });
  });

  describe('.defaultScope', function() {
    subject(() => $Klass.defaultScope);

    context('when value is not overwritten', function() {
      def('Klass', () => class Klass extends NextModel {});

      it('returns default value', function() {
        expect($subject).to.eql(undefined);
      });
    });
  });

  describe('.defaultOrder', function() {
    subject(() => $Klass.defaultOrder);

    context('when value is not overwritten', function() {
      def('Klass', () => class Klass extends NextModel {});

      it('returns default value', function() {
        expect($subject).to.eql(undefined);
      });
    });
  });

  // - computed
  describe('.keys', function() {
    subject(() => $Klass.keys);

    def('Klass', () => class Klass extends NextModel {
      static get schema() {
        return $schema;
      }

      static get attrAccessors() {
        return $attrAccessors;
      }
    });

    context('when schema is empty', function() {
      def('schema', () => ({}));

      it('returns empty array', function() {
        expect($subject).to.eql([]);
      });
    });

    context('when schema present', function() {
      def('schema', () => ({
        foo: { type: 'integer' },
      }));

      it('returns keys of schema', function() {
        expect($subject).to.eql(['foo']);
      });
    });

    context('when attrAccessors is present', function() {
      def('attrAccessors', () => ['foo']);

      it('returns keys from attrAccessors', function() {
        expect($subject).to.eql(['foo']);
      });
    });

    context('when schema and attrAccessors are present', function() {
      def('schema', () => ({
        foo: { type: 'integer' },
      }));
      def('attrAccessors', () => ['bar']);

      it('returns keys from attrAccessors', function() {
        expect($subject).to.have.length(2);
        expect($subject).to.contain('foo');
        expect($subject).to.contain('bar');
      });

      context('when both have same keys', function() {
        def('attrAccessors', () => ['foo']);

        it('returns overlapping keys once', function() {
          expect($subject).to.eql(['foo']);
        });
      });
    });
  });

  describe('.databaseKeys', function() {
    subject(() => $Klass.databaseKeys);

    def('Klass', () => class Klass extends NextModel {
      static get identifier() {
        return $identifier;
      }

      static get schema() {
        return $schema;
      }

      static get attrAccessors() {
        return $attrAccessors;
      }
    });

    context('when schema is empty', function() {
      def('schema', () => ({}));

      it('returns empty array', function() {
        expect($subject).to.eql([]);
      });
    });

    context('when schema present', function() {
      def('schema', () => ({
        foo: { type: 'integer' },
      }));

      it('returns keys of schema', function() {
        expect($subject).to.eql(['foo']);
      });

      context('when identifier is present', function() {
        def('identifier', () => 'id');

        it('returns keys of schema', function() {
          expect($subject).to.eql(['foo']);
        });
      });

      context('when identifier is in schema', function() {
        def('identifier', () => 'foo');

        it('returns keys without identifier', function() {
          expect($subject).to.eql([]);
        });
      });
    });

    context('when attrAccessors is present', function() {
      def('attrAccessors', () => ['foo']);

      it('returns no keys from attrAccessors', function() {
        expect($subject).to.eql([]);
      });
    });

    context('when schema and attrAccessors are present', function() {
      def('schema', () => ({
        foo: { type: 'integer' },
      }));
      def('attrAccessors', () => ['bar']);

      it('returns only keys from schema', function() {
        expect($subject).to.have.length(1);
        expect($subject).to.contain('foo');
      });

      context('when both have same keys', function() {
        def('attrAccessors', () => ['foo']);

          it('returns only keys from schema', function() {
          expect($subject).to.eql(['foo']);
        });
      });
    });
  });

  describe('.hasCache', function() {
    subject(() => $Klass.hasCache);
    def('Klass', () => class Klass extends NextModel {});

    beforeEach(function() {
      $Klass.cache = $cache;
    });

    context('when cache is not present', function() {
      it('returns false', function() {
        expect($subject).to.eql(false);
      });
    });

    context('when cache is empty', function() {
      def('cache', () => []);

      it('returns true', function() {
        expect($subject).to.eql(true);
      });

      context('when caching is disabled', function() {
        def('Klass', () => class Klass extends $Klass {
          static get useCache() {
            return false;
          }
        });

        it('returns false', function () {
          expect($subject).to.eql(false);
        });
      });
    });

    context('when cache is present', function() {
      def('cache', () => [{ foo: 'bar' }]);

      it('returns true', function() {
        expect($subject).to.eql(true);
      });
    });
  });

  describe('.all', function() {
    subject(() => $Klass.all);

    def('Klass', () => class Klass extends NextModel {
      static get modelName() {
        return 'Klass';
      }

      static get schema() {
        return {
          id: { type: 'integer' },
          foo: { type: 'string' },
        };
      }

      static get defaultScope() {
        return $defaultScope;
      }

      static get defaultOrder() {
        return $defaultOrder;
      }
    });

    it('throws error without connector', function () {
      expect(() => $subject).to.throwError();
    });

    context('when cache is present', function() {
      beforeEach(function() {
        $Klass.cache = [
          { id: 1, foo: 'foo' },
          { id: 2, foo: 'foo' },
          { id: 3, foo: 'bar' },
        ];
      });

      it('returns cached data', function () {
        return $subject.then(data => expect(map(data, 'id')).to.eql([1, 2, 3]));
      });

      context('when defaultScope present', function() {
        def('defaultScope', () => ({ foo: 'foo' }));

        it('returns matching cached data', function () {
          return $subject.then(data => expect(map(data, 'id')).to.eql([1, 2]));
        });
      });

      context('when defaultOrder present', function() {
        def('defaultOrder', () => ({ id: 'desc' }));

        it('returns matching cached data', function () {
          return $subject.then(data => expect(map(data, 'id')).to.eql([3, 2, 1]));
        });
      });

      context('when caching is disabled', function() {
        def('Klass', () => class Klass extends $Klass {
          static get useCache() {
            return false;
          }
        });

        it('throws error without connector', function () {
          expect(() => $subject).to.throwError();
        });
      });
    });

    context('when connector is present', function() {
      def('Klass', () => class Klass extends $Klass {
        static get connector() {
          return { all: function() {
            return Promise.resolve([{id: 1, foo: 'bar'}]);
          }};
        }
      });

      it('returns queried data', function () {
        return $subject.then(data => expect(map(data, 'id')).to.eql([1]));
      });

      context('when cache is present', function() {
        beforeEach(function() {
          $Klass.cache = [
            { id: 1, foo: 'foo' },
            { id: 2, foo: 'foo' },
            { id: 3, foo: 'bar' },
          ];
        });

        it('returns cached data', function () {
          return $subject.then(data => expect(map(data, 'id')).to.eql([1, 2, 3]));
        });

        context('when caching is disabled', function() {
          def('Klass', () => class Klass extends $Klass {
            static get useCache() {
              return false;
            }
          });

          it('returns queried data', function () {
            return $subject.then(data => expect(map(data, 'id')).to.eql([1]));
          });
        });
      });
    });
  });

  describe('.first', function() {
    subject(() => $Klass.first);

    def('Klass', () => class Klass extends NextModel {
      static get modelName() {
        return 'Klass';
      }

      static get schema() {
        return {
          id: {type: 'integer'},
          foo: {type: 'string'},
        };
      }

      static get defaultScope() {
        return $defaultScope;
      }

      static get defaultOrder() {
        return $defaultOrder;
      }
    });

    it('throws error without connector', function () {
      expect(() => $subject).to.throwError();
    });

    context('when cache is present', function() {
      beforeEach(function() {
        $Klass.cache = [
          { id: 1, foo: 'foo' },
          { id: 2, foo: 'foo' },
          { id: 3, foo: 'bar' },
        ];
      });

      it('returns cached data', function () {
        return $subject.then(data => expect(data).to.eql({ id: 1, foo: 'foo' }));
      });

      context('when defaultScope present', function() {
        def('defaultScope', () => ({ foo: 'foo' }));

        it('returns matching cached data', function () {
          return $subject.then(data => expect(data).to.eql({ id: 1, foo: 'foo' }));
        });
      });

      context('when defaultOrder present', function() {
        def('defaultOrder', () => ({ id: 'desc' }));

        it('returns matching cached data', function () {
          return $subject.then(data => expect(data).to.eql({ id: 3, foo: 'bar' }));
        });
      });

      context('when caching is disabled', function() {
        def('Klass', () => class Klass extends $Klass {
          static get useCache() {
            return false;
          }
        });

        it('throws error without connector', function () {
          expect(() => $subject).to.throwError();
        });
      });
    });

    context('when connector is present', function() {
      def('Klass', () => class Klass extends $Klass {
        static get connector() {
          return { first: function() {
            return Promise.resolve({ id: 2, foo: 'bar' });
          }};
        }
      });

      it('returns queried data', function () {
        return $subject.then(data => expect(data).to.eql({ id: 2, foo: 'bar' }));
      });

      context('when cache is present', function() {
        beforeEach(function() {
          $Klass.cache = [{ id: 1, foo: 'foo' }];
        });

        it('returns cached data', function () {
          return $subject.then(data => expect(data).to.eql({ id: 1, foo: 'foo' }));
        });

        context('when caching is disabled', function() {
          def('Klass', () => class Klass extends $Klass {
            static get useCache() {
              return false;
            }
          });

          it('returns queried data', function () {
            return $subject.then(data => expect(data).to.eql({ id: 2, foo: 'bar' }));
          });
        });
      });
    });
  });

  describe('.last', function() {
    subject(() => $Klass.last);

    def('Klass', () => class Klass extends NextModel {
      static get modelName() {
        return 'Klass';
      }

      static get schema() {
        return {
          id: { type: 'integer' },
          foo: { type: 'string' },
        };
      }

      static get defaultScope() {
        return $defaultScope;
      }

      static get defaultOrder() {
        return $defaultOrder;
      }
    });

    it('throws error without connector', function () {
      expect(() => $subject).to.throwError();
    });

    context('when cache is present', function() {
      beforeEach(function() {
        $Klass.cache = [
          { id: 1, foo: 'foo' },
          { id: 2, foo: 'foo' },
          { id: 3, foo: 'bar' },
        ];
      });

      it('returns cached data', function () {
        return $subject.then(data => expect(data).to.eql({ id: 3, foo: 'bar' }));
      });

      context('when defaultScope present', function() {
        def('defaultScope', () => ({ foo: 'foo' }));

        it('returns matching cached data', function () {
          return $subject.then(data => expect(data).to.eql({ id: 2, foo: 'foo' }));
        });
      });

      context('when defaultOrder present', function() {
        def('defaultOrder', () => ({ id: 'desc' }));

        it('returns matching cached data', function () {
          return $subject.then(data => expect(data).to.eql({ id: 1, foo: 'foo' }));
        });
      });

      context('when caching is disabled', function() {
        def('Klass', () => class Klass extends $Klass {
          static get useCache() {
            return false;
          }
        });

        it('throws error without connector', function () {
          expect(() => $subject).to.throwError();
        });
      });
    });

    context('when connector is present', function() {
      def('Klass', () => class Klass extends $Klass {
        static get connector() {
          return { last: function() {
            return Promise.resolve({ id: 2, foo: 'bar' });
          }};
        }
      });

      it('returns queried data', function () {
        return $subject.then(data => expect(data).to.eql({ id: 2, foo: 'bar' }));
      });

      context('when cache is present', function() {
        beforeEach(function() {
          $Klass.cache = [{ id: 1, foo: 'foo' }];
        });

        it('returns cached data', function () {
          return $subject.then(data => expect(data).to.eql({ id: 1, foo: 'foo' }));
        });

        context('when caching is disabled', function() {
          def('Klass', () => class Klass extends $Klass {
            static get useCache() {
              return false;
            }
          });

          it('returns queried data', function () {
            return $subject.then(data => expect(data).to.eql({ id: 2, foo: 'bar' }));
          });
        });
      });
    });
  });

  describe('.count', function() {
    subject(() => $Klass.count);

    def('Klass', () => class Klass extends NextModel {
      static get modelName() {
        return 'Klass';
      }

      static get schema() {
        return {
          id: { type: 'integer' },
          foo: { type: 'string' },
        };
      }

      static get defaultScope() {
        return $defaultScope;
      }

      static get defaultOrder() {
        return $defaultOrder;
      }
    });

    it('throws error without connector', function () {
      expect(() => $subject).to.throwError();
    });

    context('when cache is present', function() {
      beforeEach(function() {
        $Klass.cache = [
          { id: 1, foo: 'foo' },
          { id: 2, foo: 'foo' },
          { id: 3, foo: 'bar' },
        ];
      });

      it('returns cache length', function () {
        return $subject.then(data => expect(data).to.eql(3));
      });

      context('when defaultOrder present', function() {
        def('defaultOrder', () => ({ id: 'desc' }));

        it('does not change count', function () {
          return $subject.then(data => expect(data).to.eql(3));
        });
      });

      context('when defaultScope present', function() {
        def('defaultScope', () => ({ foo: 'foo' }));

        it('returns length of matching cached data', function () {
          return $subject.then(data => expect(data).to.eql(2));
        });
      });
    });

    context('when connector is present', function() {
      def('Klass', () => class Klass extends $Klass {
        static get connector() {
          return { count: function() {
            return Promise.resolve(2);
          }};
        }
      });

      it('returns queried data', function () {
        return $subject.then(data => expect(data).to.eql(2));
      });

      context('when cache is present', function() {
        beforeEach(function() {
          $Klass.cache = [{ id: 1, foo: 'foo' }];
        });

        it('returns cached data', function () {
          return $subject.then(data => expect(data).to.eql(1));
        });

        context('when caching is disabled', function() {
          def('Klass', () => class Klass extends $Klass {
            static get useCache() {
              return false;
            }
          });

          it('returns queried data', function () {
            return $subject.then(data => expect(data).to.eql(2));
          });
        });
      });
    });
  });

  describe('.model', function() {
    subject(() => $Klass.model);

    def('Klass', () => class Klass extends NextModel {
      static get modelName() {
        return 'Klass';
      }

      static get schema() {
        return {
          id: { type: 'integer' },
          foo: { type: 'string' },
        };
      }

      static get defaultScope() {
        return $defaultScope;
      }

      static get defaultOrder() {
        return $defaultOrder;
      }
    });

    it('ruturns a NextModel', function() {
      expect($subject).to.be.a('function');
      expect($subject.modelName).to.eql('Klass');
    });

    context('cache is present', function() {
      beforeEach(function() {
        $Klass.cache = [{ foo: 1 }];
      });

      it('clears cache', function() {
        expect($subject.cache).to.eql(undefined);
      });
    });

    context('defaultScope is present', function() {
      def('defaultScope', () => ({ foo: 1 }));

      it('sets scope to undefined', function() {
        expect($subject.defaultScope).to.eql(undefined);
      });
    });

    context('defaultOrder is present', function() {
      def('defaultOrder', () => ({ foo: 'asc' }));

      it('sets order to undefined', function() {
        expect($subject.defaultOrder).to.eql(undefined);
      });
    });
  });

  describe('.withoutScope', function() {
    subject(() => $Klass.withoutScope);

    def('Klass', () => class Klass extends NextModel {
      static get modelName() {
        return 'Klass';
      }

      static get schema() {
        return {
          id: { type: 'integer' },
          foo: { type: 'string' },
        };
      }

      static get defaultScope() {
        return $defaultScope;
      }

      static get defaultOrder() {
        return $defaultOrder;
      }
    });

    it('ruturns a NextModel', function() {
      expect($subject).to.be.a('function');
      expect($subject.modelName).to.eql('Klass');
    });

    context('cache is present', function() {
      beforeEach(function() {
        $Klass.cache = [{ foo: 1 }];
      });

      it('clears cache', function() {
        expect($subject.cache).to.eql(undefined);
      });
    });

    context('defaultScope is present', function() {
      def('defaultScope', () => ({ foo: 1 }));

      it('sets scope to undefined', function() {
        expect($subject.defaultScope).to.eql(undefined);
      });
    });

    context('defaultOrder is present', function() {
      def('defaultOrder', () => ({ foo: 'asc' }));

      it('keeps order', function() {
        expect($subject.defaultOrder).to.eql({ foo: 'asc' });
      });
    });
  });

  describe('.unorder', function() {
    subject(() => $Klass.unorder);

    def('Klass', () => class Klass extends NextModel {
      static get modelName() {
        return 'Klass';
      }

      static get schema() {
        return {
          id: { type: 'integer' },
          foo: { type: 'string' },
        };
      }

      static get defaultScope() {
        return $defaultScope;
      }

      static get defaultOrder() {
        return $defaultOrder;
      }
    });

    it('ruturns a NextModel', function() {
      expect($subject).to.be.a('function');
      expect($subject.modelName).to.eql('Klass');
    });

    context('cache is present', function() {
      beforeEach(function() {
        $Klass.cache = [{ foo: 1 }];
      });

      it('keeps cache', function() {
        expect($subject.cache).to.eql([{ foo: 1 }]);
      });
    });

    context('defaultScope is present', function() {
      def('defaultScope', () => ({ foo: 1 }));

      it('keeps default scope', function() {
        expect($subject.defaultScope).to.eql({ foo: 1 });
      });
    });

    context('defaultOrder is present', function() {
      def('defaultOrder', () => ({ foo: 'asc' }));

      it('sets order to undefined', function() {
        expect($subject.defaultOrder).to.eql(undefined);
      });
    });
  });

  describe('.reload', function() {
    subject(() => $Klass.reload);

    def('Klass', () => class Klass extends NextModel {
      static get modelName() {
        return 'Klass';
      }

      static get schema() {
        return {
          id: { type: 'integer' },
          foo: { type: 'string' },
        };
      }

      static get defaultScope() {
        return $defaultScope;
      }

      static get defaultOrder() {
        return $defaultOrder;
      }
    });

    it('ruturns a NextModel', function() {
      expect($subject).to.be.a('function');
      expect($subject.modelName).to.eql('Klass');
    });

    context('cache is present', function() {
      beforeEach(function() {
        $Klass.cache = [{ foo: 1 }];
      });

      it('clears cache', function() {
        expect($subject.cache).to.eql(undefined);
      });
    });

    context('defaultScope is present', function() {
      def('defaultScope', () => ({ foo: 1 }));

      it('keeps scope', function() {
        expect($subject.defaultScope).to.eql({ foo: 1 });
      });
    });

    context('defaultOrder is present', function() {
      def('defaultOrder', () => ({ foo: 'asc' }));

      it('keeps order', function() {
        expect($subject.defaultOrder).to.eql({ foo: 'asc' });
      });
    });
  });

  // Static functions
  describe('.build()', function() {
    subject(() => $Klass.build($attrs));

    def('schema', () => ({}));

    def('Klass', () => class Klass extends NextModel {
      static get modelName() {
        return 'Klass';
      }

      static get schema() {
        return $schema;
      }

      static get attrAccessors() {
        return $attrAccessors;
      }
    });

    it('returns model instance', function() {
      expect($subject).to.be.a($Klass);
    });

    context('when schema is present', function() {
      def('schema', () => ({
        id: { type: 'integer' },
        bar: { type: 'string', defaultValue: 'bar' },
      }));

      it('returns model instance and sets default values', function() {
        expect($subject).to.be.a($Klass);
        expect($subject.id).to.eql(null);
        expect($subject.bar).to.eql('bar');
      });

      context('when passing attributes to constructor', function() {
        def('attrs', () => ({
          bar: 'foo',
        }));

        it('returns model instance and sets attributes', function() {
          expect($subject).to.be.a($Klass);
          expect($subject.id).to.eql(null);
          expect($subject.bar).to.eql('foo');
        });

        context('when passing id', function() {
          def('attrs', () => ({
            id: 1,
            bar: 'foo',
          }));

          it('throws error while creating', function() {
            expect(() => $subject).to.throwError();
          });
        });
      });

      context('when passing invalid attributes to constructor', function() {
        def('attrs', () => ({
          baz: 'foo',
        }));

        it('throws error while creating', function() {
          expect(() => $subject).to.throwError();
        });
      });

      context('when attrAccessors are present', function() {
        def('attrAccessors', () => ['baz']);

        it('does not set accessor', function() {
          expect($subject).to.be.a($Klass);
          expect($subject.baz).to.eql(undefined);
        });

        context('when passing attributes to constructor', function() {
          def('attrs', () => ({
            baz: 'foo',
          }));

          it('returns model instance and sets attributes', function() {
            expect($subject).to.be.a($Klass);
            expect($subject.baz).to.eql('foo');
          });
        });
      });
    });
  });

  describe('.create()', function() {
    subject(() => $Klass.create($attrs));

    def('schema', () => ({}));

    def('Klass', () => class Klass extends NextModel {
      static get connector() {
        return { save: function(klass) {
          klass.id = 1;
          return Promise.resolve(true);
        }};
      }

      static get modelName() {
        return 'Klass';
      }

      static get schema() {
        return $schema;
      }

      static get attrAccessors() {
        return $attrAccessors;
      }
    });

    it('returns model instance', function() {
      return $subject.then(data => expect(data).to.be.a($Klass));
    });

    context('when schema is present', function() {
      def('schema', () => ({
        id: { type: 'integer' },
        bar: { type: 'string', defaultValue: 'bar' },
      }));

      it('returns model instance and sets default values', function() {
        return $subject.then(data => {
          expect(data).to.be.a($Klass);
          expect(data.id).to.eql(1);
          expect(data.bar).to.eql('bar');
        });
      });

      context('when passing attributes to constructor', function() {
        def('attrs', () => ({
          bar: 'foo',
        }));

        it('returns model instance and sets attributes', function() {
          return $subject.then(data => {
            expect(data).to.be.a($Klass);
            expect(data.id).to.eql(1);
            expect(data.bar).to.eql('foo');
          });
        });

        context('when passing id', function() {
          def('attrs', () => ({
            id: 1,
            bar: 'foo',
          }));

          it('throws error while creating', function() {
            expect(() => $subject).to.throwError();
          });
        });
      });

      context('when passing invalid attributes to constructor', function() {
        def('attrs', () => ({
          baz: 'foo',
        }));

        it('throws error while creating', function() {
          expect(() => $subject).to.throwError();
        });
      });

      context('when attrAccessors are present', function() {
        def('attrAccessors', () => ['baz']);

        it('does not set accessor', function() {
          return $subject.then(data => {
            expect(data).to.be.a($Klass);
            expect(data.baz).to.eql(undefined);
          });
        });

        context('when passing attributes to constructor', function() {
          def('attrs', () => ({
            baz: 'foo',
          }));

          it('returns model instance and sets attributes', function() {
            return $subject.then(data => {
              expect(data).to.be.a($Klass);
              expect(data.baz).to.eql('foo');
            });
          });
        });
      });
    });
  });

  describe('.limit()', function() {
    subject(() => $Klass.limit($amount));

    def('Klass', () => class Klass extends NextModel {
      static get modelName() {
        return 'Klass';
      }

      static get schema() {
        return {
          id: { type: 'integer' },
          foo: { type: 'string' },
        };
      }

      static get defaultScope() {
        return $defaultScope;
      }
    });

    context('when limit is a number', function () {
      def('amount', () => 1);

      it('throws no error', function () {
        expect(() => $subject).to.not.throwError();
      });
    });


    context('when limit is no number', function () {
      def('amount', () => 'a');

      it('throws error', function () {
        expect(() => $subject).to.throwError();
      });
    });

    context('when limit below 0', function () {
      def('amount', () => -1);

      it('throws error', function () {
        expect(() => $subject).to.throwError();
      });
    });

    context('when cache is present', function() {
      def('cache', () => [
        { id: 1, foo: 'foo' },
        { id: 2, foo: 'foo' },
        { id: 3, foo: 'bar' },
        { id: 4, foo: 'bar' },
      ]);
      beforeEach(function() {
        $Klass.cache = $cache;
      });

      context('when fetching records', function() {
        subject(() => $Klass.limit($amount).all);

        context('when limit is heigher than record count' , function() {
          def('amount', () => 10);

          it('returns all records', function () {
            return $subject.then(data => expect(data).to.eql($cache));
          });
        });

        context('when limit is lower than record count' , function() {
          def('amount', () => 2);

          it('takes the records from start', function () {
            return $subject.then(data => expect(data).to.eql([$cache[0], $cache[1]]));
          });
        });

        context('when defaultScope present', function() {
          def('amount', () => 1);
          def('defaultScope', () => ({ foo: 'bar' }));

          it('limits matching cached data', function () {
            return $subject.then(data => expect(data).to.eql([$cache[2]]));
          });
        });
      });
    });
  });

  describe('.unlimit()', function() {
    def('Klass', () => class Klass extends NextModel {
      static get modelName() {
        return 'Klass';
      }

      static get schema() {
        return {
          id: { type: 'integer' },
          foo: { type: 'string' },
        };
      }

      static get defaultScope() {
        return $defaultScope;
      }
    });

    context('when cache is present', function() {
      def('cache', () => [
        { id: 1, foo: 'foo' },
        { id: 2, foo: 'foo' },
        { id: 3, foo: 'bar' },
        { id: 4, foo: 'bar' },
      ]);
      beforeEach(function() {
        $Klass.cache = $cache;
      });

      context('when fetching records', function() {
        subject(() => $Klass.unlimit().all);

        it('returns all records', function () {
          return $subject.then(data => expect(data).to.eql($cache));
        });

        context('when limit is present' , function() {
          def('Klass', () => $Klass.limit(1));

          it('returns all records', function () {
            return $subject.then(data => expect(data).to.eql($cache));
          });
        });
      });
    });
  });

  describe('.skip()', function() {
    subject(() => $Klass.skip($amount));

    def('Klass', () => class Klass extends NextModel {
      static get modelName() {
        return 'Klass';
      }

      static get schema() {
        return {
          id: { type: 'integer' },
          foo: { type: 'string' },
        };
      }

      static get defaultScope() {
        return $defaultScope;
      }
    });

    context('when skip is a number', function () {
      def('amount', () => 1);

      it('throws no error', function () {
        expect(() => $subject).to.not.throwError();
      });
    });


    context('when skip is no number', function () {
      def('amount', () => 'a');

      it('throws error', function () {
        expect(() => $subject).to.throwError();
      });
    });

    context('when skip below 0', function () {
      def('amount', () => -1);

      it('throws error', function () {
        expect(() => $subject).to.throwError();
      });
    });

    context('when cache is present', function() {
      def('cache', () => [
        { id: 1, foo: 'foo' },
        { id: 2, foo: 'foo' },
        { id: 3, foo: 'bar' },
        { id: 4, foo: 'bar' },
      ]);
      beforeEach(function() {
        $Klass.cache = $cache;
      });

      context('when fetching records', function() {
        subject(() => $Klass.skip($amount).all);

        context('when skip is heigher than record count' , function() {
          def('amount', () => 10);

          it('returns no records', function () {
            return $subject.then(data => expect(data).to.eql([]));
          });
        });

        context('when skip is lower than record count' , function() {
          def('amount', () => 2);

          it('skips the records from start', function () {
            return $subject.then(data => expect(data).to.eql([$cache[2], $cache[3]]));
          });
        });

        context('when defaultScope present', function() {
          def('amount', () => 1);
          def('defaultScope', () => ({ foo: 'bar' }));

          it('skips matching cached data', function () {
            return $subject.then(data => expect(data).to.eql([$cache[3]]));
          });
        });
      });
    });
  });

  describe('.unskip()', function() {
    def('Klass', () => class Klass extends NextModel {
      static get modelName() {
        return 'Klass';
      }

      static get schema() {
        return {
          id: { type: 'integer' },
          foo: { type: 'string' },
        };
      }

      static get defaultScope() {
        return $defaultScope;
      }
    });

    context('when cache is present', function() {
      def('cache', () => [
        { id: 1, foo: 'foo' },
        { id: 2, foo: 'foo' },
        { id: 3, foo: 'bar' },
        { id: 4, foo: 'bar' },
      ]);
      beforeEach(function() {
        $Klass.cache = $cache;
      });

      context('when fetching records', function() {
        subject(() => $Klass.unskip().all);

        it('returns all records', function () {
          return $subject.then(data => expect(data).to.eql($cache));
        });

        context('when skip is present' , function() {
          def('Klass', () => $Klass.skip(1));

          it('returns all records', function () {
            return $subject.then(data => expect(data).to.eql($cache));
          });
        });
      });
    });
  });

  describe('.withScope()', function() {
    subject(() => $Klass.withScope($scope));
    def('scope', () => ({ foo: 'bar' }));

    def('Klass', () => class Klass extends NextModel {
      static get modelName() {
        return 'Klass';
      }

      static get schema() {
        return {
          foo: { type: 'integer' },
          bar: { type: 'integer' },
        };
      }

      static get defaultScope() {
        return $defaultScope;
      }
    });

    it('ruturns a NextModel', function() {
      expect($subject).to.be.a('function');
      expect($subject.modelName).to.eql('Klass');
    });

    it('passes scope to defaultScope', function() {
      expect($subject.defaultScope).to.eql($scope);
    });

    context('when key is not in schema', function() {
      def('scope', () => ({ baz: 'foo' }));

      it('throws error', function() {
        expect(() => $subject).to.throwError();
      });
    });

    context('defaultScope is already present', function() {
      def('defaultScope', () => ({ bar: 'baz' }));

      it('overrides current scope', function() {
        expect($subject.defaultScope).to.eql($scope);
      });

      context('defaultScope is already present with same key', function() {
        def('defaultScope', () => ({ foo: 'baz' }));

        it('overrides current scope', function() {
          expect($subject.defaultScope).to.eql($scope);
        });
      });
    });
  });

  describe('.order()', function() {
    subject(() => $Klass.order($order));
    def('order', () => ({ foo: 'asc' }));

    def('Klass', () => class Klass extends NextModel {
      static get modelName() {
        return 'Klass';
      }

      static get schema() {
        return {
          foo: { type: 'integer' },
          bar: { type: 'integer' },
        };
      }

      static get defaultOrder() {
        return $defaultOrder;
      }
    });

    it('ruturns a NextModel', function() {
      expect($subject).to.be.a('function');
      expect($subject.modelName).to.eql('Klass');
    });

    it('passes order to defaultOrder', function() {
      expect($subject.defaultOrder).to.eql($order);
    });

    context('when value is invalid', function() {
      def('order', () => ({ foo: 1 }));

      it('throws error', function() {
        expect(() => $subject).to.throwError();
      });
    });

    context('when key is not in schema', function() {
      def('order', () => ({ baz: 'asc' }));

      it('throws error', function() {
        expect(() => $subject).to.throwError();
      });
    });

    context('defaultOrder is already present', function() {
      def('defaultOrder', () => ({ bar: 'desc' }));

      it('overrides current order', function() {
        expect($subject.defaultOrder).to.eql($order);
      });

      context('defaultOrder is already present with same key', function() {
        def('defaultOrder', () => ({ foo: 'desc' }));

        it('overrides current order', function() {
          expect($subject.defaultOrder).to.eql($order);
        });
      });
    });
  });

  describe('.scope()', function() {
    subject(() => $Klass.scope({ where: $scope }));
    def('scope', () => ({ foo: 'bar' }));

    def('Klass', () => class Klass extends NextModel {
      static get modelName() {
        return 'Klass';
      }

      static get schema() {
        return {
          foo: { type: 'integer' },
          bar: { type: 'integer' },
        };
      }

      static get defaultScope() {
        return $defaultScope;
      }
    });

    it('ruturns a NextModel', function() {
      expect($subject).to.be.a('function');
      expect($subject.modelName).to.eql('Klass');
    });

    it('passes scope to defaultScope', function() {
      expect($subject.defaultScope).to.eql({ foo: 'bar' });
    });

    context('when key is not in schema', function() {
      def('scope', () => ({ baz: 'bar' }));

      it('throws error', function() {
        expect(() => $subject).to.throwError();
      });
    });

    context('defaultScope is already present', function() {
      def('defaultScope', () => ({ bar: 'baz' }));

      it('merges current scope', function() {
        expect($subject.defaultScope).to.eql({ foo: 'bar', bar: 'baz' });
      });

      context('defaultScope is already present with same key', function() {
        def('defaultScope', () => ({ foo: 'baz' }));

        it('throws error', function() {
          expect(() => $subject).to.throwError();
        });
      });
    });
  });

  describe('.unscope()', function() {
    subject(() => $Klass.unscope($args));
    def('args', () => 'foo');
    def('defaultScope', () => ({ foo : 1 }));

    def('Klass', () => class Klass extends NextModel {
      static get modelName() {
        return 'Klass';
      }

      static get schema() {
        return {
          foo: { type: 'integer' },
          bar: { type: 'integer' },
        };
      }

      static get defaultScope() {
        return $defaultScope;
      }
    });

    it('ruturns a NextModel', function() {
      expect($subject).to.be.a('function');
      expect($subject.modelName).to.eql('Klass');
    });

    it('removes scope from defaultScope', function() {
      expect($Klass.defaultScope).to.eql($defaultScope);
      expect($subject.defaultScope).to.eql({ });
    });

    context('when key is not in schema', function() {
      def('args', () => 'baz');

      it('does not change the defaultScope', function() {
        expect($subject.defaultScope).to.eql($defaultScope);
      });
    });

    context('defaultScope has multiple attributes', function() {
      def('defaultScope', () => ({ foo: 1, bar: 2 }));

      it('just removes one property of scope', function() {
        expect($subject.defaultScope).to.eql({ bar: 2 });
      });

      context('when unscoping multiple properties', function() {
        def('args', () => ['foo', 'bar']);

        it('removed all properties by key', function() {
          expect($subject.defaultScope).to.eql({ });
        });
      });
    });
  });

  describe('.where()', function() {
    subject(() => $Klass.where($scope));
    def('scope', () => ({ foo: 'bar' }));

    def('Klass', () => class Klass extends NextModel {
      static get modelName() {
        return 'Klass';
      }

      static get schema() {
        return {
          foo: { type: 'integer' },
          bar: { type: 'integer' },
        };
      }

      static get defaultScope() {
        return $defaultScope;
      }
    });

    it('ruturns a NextModel', function() {
      expect($subject).to.be.a('function');
      expect($subject.modelName).to.eql('Klass');
    });

    it('passes scope to defaultScope', function() {
      expect($subject.defaultScope).to.eql({ foo: 'bar' });
    });

    context('when key is not in schema', function() {
      def('scope', () => ({ baz: 'bar' }));

      it('throws error', function() {
        expect(() => $subject).to.throwError();
      });
    });

    context('defaultScope is already present', function() {
      def('defaultScope', () => ({ bar: 'baz' }));

      it('merges current scope', function() {
        expect($subject.defaultScope).to.eql({ foo: 'bar', bar: 'baz' });
      });

      context('defaultScope is already present with same key', function() {
        def('defaultScope', () => ({ foo: 'baz' }));

        it('throws error', function() {
          expect(() => $subject).to.throwError();
        });
      });
    });
  });

  describe('.createTable()', function() {
    subject(() => $Klass.createTable());

    context('when connector is present', function() {
      def('Klass', () => class Klass extends NextModel {
        static get connector() {
          return { createTable: function(Klass) {
            return Promise.resolve('called');
          }};
        }
      });

      it('calls the createTable function of the connector', function() {
        return $subject.then(data => expect(data).to.eql('called'));
      });
    });

    context('when connector is not present', function() {
      def('Klass', () => class Klass extends NextModel {});

      it('throws error if connector is not overwritten', function() {
        expect(() => $subject).to.throwError();
      });
    });
  });

  describe('.fetchSchema()', function() {
    subject(() => $Klass.fetchSchema());

    def('Klass', () => class Klass extends NextModel {
      static get modelName() {
        return 'Klass';
      }

      static get schema() {
        return $schema;
      }

      static get belongsTo() {
        return $belongsTo;
      }
    });

    it('returns empty schema', function() {
      expect($subject).to.eql({});
    });

    context('when schema is present', function() {
      def('schema', () => ({
        foo: { type: 'integer', defaultValue: 1 },
        bar: { type: 'integer', defaultValue: 2 },
      }));

      it('returns schema', function() {
        expect($subject).to.eql({
          foo: { type: 'integer', defaultValue: 1 },
          bar: { type: 'integer', defaultValue: 2 },
        });
      });
    });

    context('when type is not present', function() {
      def('schema', () => ({
        foo: { defaultValue: 'foo' },
        bar: { type: 'integer', defaultValue: 2 },
      }));

      it('adds type string if no type is present', function() {
        expect($subject).to.eql({
          foo: { type: 'string', defaultValue: 'foo' },
          bar: { type: 'integer', defaultValue: 2 },
        });
      });
    });

    context('when defaultValue is not present', function() {
      def('schema', () => ({
        foo: { type: 'integer' },
        bar: { type: 'integer', defaultValue: 2 },
      }));

      it('adds type string if no type is present', function() {
        expect($subject).to.eql({
          foo: {type: 'integer', defaultValue: null},
          bar: {type: 'integer', defaultValue: 2},
        });
      });
    });

    context('when belongsTo relation is present', function() {
      def('Foo', () => class Foo extends NextModel {
        static get modelName() {
          return 'Foo';
        }

        static get schema() {
          return {
            id: { type: 'integer' },
          };
        }
      });

      def('belongsTo', () => ({
        foo: { model: $Foo },
      }));

      it('adds join column to schema', function() {
        expect($subject).to.eql({ fooId: { type: 'integer', defaultValue: null }});
      });

      context('when belongsTo relation has foreignKey', function() {
        def('belongsTo', () => ({
          foo: { model: $Foo, foreignKey: 'baz' },
        }));

        it('adds join column to schema', function() {
          expect($subject).to.eql({ baz: { type: 'integer', defaultValue: null }});
        });
      });
    });

    context('when belongsTo relation class has identifier', function() {
      def('Foo', () => class Foo extends NextModel {
        static get modelName() {
          return 'Foo';
        }

        static get schema() {
          return {
            guid: { type: 'guid' },
          };
        }

        static get identifier() {
          return 'guid';
        }
      });

      def('belongsTo', () => ({
        foo: { model: $Foo },
      }));

      it('used identifier column as reverse lookup', function() {
        expect($subject).to.eql({ fooId: { type: 'guid', defaultValue: null }});
      });
    });

    context('when belongsTo relation class has defaultValue', function() {
      def('Foo', () => class Foo extends NextModel {
        static get modelName() {
          return 'Foo';
        }

        static get schema() {
          return {
            id: { type: 'integer', defaultValue: 0 },
          };
        }
      });

      def('belongsTo', () => ({
        foo: { model: $Foo },
      }));

      it('adds join column to schema', function() {
        expect($subject).to.eql({ fooId: { type: 'integer', defaultValue: 0 }});
      });
    });
  });

  describe('.fetchBelongsTo()', function() {
    subject(() => $Klass.fetchBelongsTo());

    def('Klass', () => class Klass extends NextModel {
      static get modelName() {
        return 'Klass';
      }

      static get belongsTo() {
        return {
          foo: { model: $Foo },
          bar: { model: $Foo, foreignKey: 'bazId' },
        };
      }
    });

    def('Foo', () => class Foo extends NextModel {
      static get modelName() {
        return 'Foo';
      }
    });

    it('prefills foreignKey if foreignKey is not present', function() {
      expect($subject).to.eql({
        foo: { model: $Foo, foreignKey: 'fooId' },
        bar: { model: $Foo, foreignKey: 'bazId' },
      });
    });
  });

  describe('.fetchHasMany()', function() {
    subject(() => $Klass.fetchHasMany());

    def('Klass', () => class Klass extends NextModel {
      static get modelName() {
        return 'Klass';
      }

      static get hasMany() {
        return {
          foo: { model: $Foo },
          bar: { model: $Foo, foreignKey: 'bazId' },
        };
      }
    });

    def('Foo', () => class Foo extends NextModel {
      static get modelName() {
        return 'Foo';
      }
    });

    it('prefills foreignKey if foreignKey is not present', function() {
      expect($subject).to.eql({
        foo: { model: $Foo, foreignKey: 'klassId' },
        bar: { model: $Foo, foreignKey: 'bazId' },
      });
    });
  });

  describe('.fetchHasOne()', function() {
    subject(() => $Klass.fetchHasOne());

    def('Klass', () => class Klass extends NextModel {
      static get modelName() {
        return 'Klass';
      }

      static get hasOne() {
        return {
          foo: { model: $Foo },
          bar: { model: $Foo, foreignKey: 'bazId' },
        };
      }
    });

    def('Foo', () => class Foo extends NextModel {
      static get modelName() {
        return 'Foo';
      }
    });

    it('prefills foreignKey if foreignKey is not present', function() {
      expect($subject).to.eql({
        foo: { model: $Foo, foreignKey: 'klassId' },
        bar: { model: $Foo, foreignKey: 'bazId' },
      });
    });
  });

  describe('.constructor', function() {
    subject(() => new $Klass($args));
    def('schema', () => ({}));
    def('belongsTo', () => ({}));
    def('hasMany', () => ({}));
    def('hasOne', () => ({}));

    def('Klass', () => class Klass extends NextModel {
      static get modelName() {
        return 'Klass';
      }

      static get schema() {
        return $schema;
      }

      static get belongsTo() {
        return $belongsTo;
      }

      static get hasMany() {
        return $hasMany;
      }

      static get hasOne() {
        return $hasOne;
      }

      static get attrAccessors() {
        return $attrAccessors;
      }
    });

    def('Foo', () => class Foo extends NextModel {
      static get modelName() {
        return 'Foo';
      }

      static get schema() {
        return {
          id: { type: 'integer' },
          klassId: { type: 'integer' },
        };
      }
    });

    beforeEach(function() {
      $Foo.cache = [{
        id: 1,
        klassId: 1,
      }];
    });

    it('returns model instance', function() {
      expect($subject).to.be.a($Klass);
    });

    context('when schema is present', function() {
      def('schema', () => ({
        id: { type: 'integer' },
        bar: { type: 'string', defaultValue: 'bar' },
      }));

      it('returns model instance and sets default values', function() {
        expect($subject).to.be.a($Klass);
        expect($subject.id).to.eql(null);
        expect($subject.bar).to.eql('bar');
      });

      context('when passing attributes to constructor', function() {
        def('args', () => ({
          id: 1,
          bar: 'foo',
        }));

        it('returns model instance and sets attributes', function() {
          expect($subject).to.be.a($Klass);
          expect($subject.id).to.eql(1);
          expect($subject.bar).to.eql('foo');
        });

        context('when hasMany is present', function() {
          def('hasMany', () => ({
            foos: {model: $Foo},
          }));

          it('returns scope to foreign model', function() {
            expect($subject).to.be.a($Klass);
            expect($subject.foos).to.be.a('function');
            expect($subject.foos.defaultScope).to.eql({ klassId: 1 });
          });
        });

        context('when hasOne is present', function() {
          def('hasOne', () => ({
            foo: { model: $Foo },
          }));

          it('returns scope to foreign model', function() {
            expect($subject).to.be.a($Klass);
            return $subject.foo.then(data => {
              expect(data).to.be.a($Foo);
              expect(data.attributes).to.eql({ id: 1, klassId: 1 });
            });
          });
        });
      });

      context('when passing invalid attributes to constructor', function() {
        def('args', () => ({
          baz: 'foo',
        }));

        it('throws error while creating', function() {
          expect(() => $subject).to.throwError();
        });
      });

      context('when attrAccessors are present', function() {
        def('attrAccessors', () => ['baz']);

        it('does not set accessor', function() {
          expect($subject).to.be.a($Klass);
          expect($subject.baz).to.eql(undefined);
        });

        context('when passing attributes to constructor', function() {
          def('args', () => ({
            baz: 'foo',
          }));

          it('returns model instance and sets attributes', function() {
            expect($subject).to.be.a($Klass);
            expect($subject.baz).to.eql('foo');
          });
        });
      });
    });

    context('when belongsTo is present', function() {
      def('belongsTo', () => ({
        foo: { model: $Foo },
      }));

      it('returns model instance and applies default values to foreignKey', function() {
        expect($subject).to.be.a($Klass);
        expect($subject.fooId).to.eql(null);
      });

      context('when passing attributes to constructor', function() {
        def('args', () => ({
          fooId: 1,
        }));

        it('sets passed value', function() {
          expect($subject).to.be.a($Klass);
          expect($subject.fooId).to.eql(1);
        });
      });
    });
  });

  // Properties

  describe('#attributes', function() {
    subject(() => $klass.attributes);
    def('klass', () => new $Klass($args));
    def('args', () => ({}));
    def('attrAccessors', () => []);

    def('Klass', () => class Klass extends NextModel {
      static get modelName() {
        return 'Klass';
      }

      static get schema() {
        return {
          foo: { type: 'string' },
        };
      }

      static get attrAccessors() {
        return $attrAccessors;
      }
    });

    it('returns schema defined attributes', function() {
      expect($subject).to.eql({ foo: null });
    });

    context('when attribute is set', function() {
      def('args', () => ({ foo: 'bar' }));

      it('returns value', function() {
        expect($subject).to.eql({ foo: 'bar' });
      });
    });

    context('when unknown attribute is set', function() {
      beforeEach(function() {
        $klass.baz = 'foo';
      });

      it('ignores keys which are not in schema', function() {
        expect($subject).to.eql({ foo: null });
      });
    });

    context('when attrAccessors are present', function() {
      def('attrAccessors', () => ['bar']);
      def('args', () => ({ bar: 'foo' }));

      it('also returns keys from attrAccessors', function() {
        expect($subject).to.eql({ foo: null, bar: 'foo' });
      });
    });
  });

  describe('#databaseAttributes', function() {
    subject(() => $klass.databaseAttributes);
    def('klass', () => new $Klass($args));
    def('args', () => ({}));
    def('attrAccessors', () => []);

    def('Klass', () => class Klass extends NextModel {
      static get modelName() {
        return 'Klass';
      }

      static get identifier() {
        return $identifier;
      }

      static get schema() {
        return {
          foo: { type: 'string' },
        };
      }

      static get attrAccessors() {
        return $attrAccessors;
      }
    });

    it('returns schema defined attributes', function() {
      expect($subject).to.eql({ foo: null });
    });

    context('when attribute is set', function() {
      def('args', () => ({ foo: 'bar' }));

      it('returns value', function() {
        expect($subject).to.eql({ foo: 'bar' });
      });

      context('when identifier is present', function() {
        def('identifier', () => 'id');

        it('returns attributes of schema', function() {
          expect($subject).to.eql({ foo: 'bar' });
        });
      });

      context('when identifier is in schema', function() {
        def('identifier', () => 'foo');

        it('returns attributes without identifier', function() {
          expect($subject).to.eql({});
        });
      });
    });

    context('when unknown attribute is set', function() {
      beforeEach(function() {
        $klass.baz = 'foo';
      });

      it('ignores keys which are not in schema', function() {
        expect($subject).to.eql({ foo: null });
      });
    });

    context('when attrAccessors are present', function() {
      def('attrAccessors', () => ['bar']);
      def('args', () => ({ bar: 'foo' }));

      it('only returns attributes from schema', function() {
        expect($subject).to.eql({ foo: null});
      });
    });
  });

  describe('#isNew', function() {
    subject(() => $klass.isNew);

    def('Klass', () => class Klass extends NextModel {
      static get schema() {
        return {
          id: { type: 'integer' },
          foo: { type: 'string' },
        };
      }

      static get connector() {
        return { save: function(klass) {
          klass.id = 1;
          return Promise.resolve(true);
        }};
      }
    });

    def('klass', () => $Klass.build({foo: 'bar'}));

    context('when model is build', function() {
      it('returns true', function() {
        expect($subject).to.eql(true);
      });
    });

    context('when model is created', function() {
      beforeEach(function() {
        $klass.save()
      });

      it('returns false', function() {
        expect($subject).to.eql(false);
      });
    });
  });

  describe('#isPersisted', function() {
    subject(() => $klass.isPersisted);

    def('Klass', () => class Klass extends NextModel {
      static get schema() {
        return {
          id: { type: 'integer' },
          foo: { type: 'string' },
        };
      }

      static get connector() {
        return { save: function(klass) {
          klass.id = 1;
          return Promise.resolve(true);
        }};
      }
    });

    def('klass', () => $Klass.build({foo: 'bar'}));

    context('when model is build', function() {
      it('returns false', function() {
        expect($subject).to.eql(false);
      });
    });

    context('when model is created', function() {
      beforeEach(function() {
        $klass.save()
      });

      it('returns true', function() {
        expect($subject).to.eql(true);
      });
    });
  });

  // Functions
  describe('#assignAttribute()', function() {
    subject(() => $klass.assignAttribute($key, $value));
    def('klass', () => new $Klass($args));
    def('args', () => ({}));
    def('key', () => 'foo');
    def('value', () => 'bar');

    def('Klass', () => class Klass extends NextModel {
      static get modelName() {
        return 'Klass';
      }

      static get schema() {
        return {
          foo: { type: 'string' },
        };
      }
    });


    it('assigns values for keys from schema', function() {
      expect($klass.foo).to.eql(null);
      expect($subject.foo).to.eql('bar');
      expect($klass.foo).to.eql('bar');
    });

    context('when key is not in schema', function() {
      def('key', () => 'baz');

      it('throws error', function() {
        expect(() => $subject).to.throwError()
      });
    });


    context('when attribute is already set', function() {
      def('args', () => ({ foo: 'baz' }));

      it('overrides value', function() {
        expect($klass.foo).to.eql('baz');
        expect($subject.foo).to.eql('bar');
        expect($klass.foo).to.eql('bar');
      });
    });
  });

  describe('#assign()', function() {
    subject(() => $klass.assign({[$key]: $value}));
    def('klass', () => new $Klass($args));
    def('args', () => ({}));
    def('key', () => 'foo');
    def('value', () => 'bar');

    def('Klass', () => class Klass extends NextModel {
      static get modelName() {
        return 'Klass';
      }

      static get schema() {
        return {
          foo: { type: 'string' },
        };
      }
    });


    it('assigns values for keys from schema', function() {
      expect($klass.foo).to.eql(null);
      expect($subject.foo).to.eql('bar');
      expect($klass.foo).to.eql('bar');
    });

    context('when key is not in schema', function() {
      def('key', () => 'baz');

      it('throws error', function() {
        expect(() => $subject).to.throwError()
      });
    });


    context('when attribute is already set', function() {
      def('args', () => ({ foo: 'baz' }));

      it('overrides value', function() {
        expect($klass.foo).to.eql('baz');
        expect($subject.foo).to.eql('bar');
        expect($klass.foo).to.eql('bar');
      });
    });
  });

  describe('#save()', function() {
    subject(() => $klass.save());

    def('Klass', () => class Klass extends NextModel {
      static get schema() {
        return {
          id: { type: 'integer' },
          foo: { type: 'string' },
        };
      }

      static get connector() {
        return $connector;
      }
    });

    def('klass', () => $Klass.build());

    it('throws error if connector is not overwritten', function() {
      expect(() => $subject).to.throwError();
    });

    context('when connector is present', function() {
      def('connector', () => ({ save: function(klass) {
        klass.id = 1;
        return Promise.resolve(true);
      }}));

      it('saves the record', function() {
        expect($klass.id).to.eql(null);
        expect($klass.isNew).to.eql(true);
        return $subject.then(data => {
          expect(data).to.be.a($Klass);
          expect(data.id).to.eql(1);
          expect(data.isNew).to.eql(false);
        });
      });
    });
  });

  describe('#delete()', function() {
    subject(() => $klass.delete());

    def('Klass', () => class Klass extends NextModel {
      static get schema() {
        return {
          id: { type: 'integer' },
          foo: { type: 'string' },
        };
      }

      static get connector() {
        return $connector;
      }
    });

    def('klass', () => $Klass.build());
    beforeEach(function() {
      $klass.id = 1;
    });

    it('throws error if connector is not overwritten', function() {
      expect(() => $subject).to.throwError();
    });

    context('when connector is present', function() {
      def('connector', () => ({ delete: function(klass) {
        delete klass.id;
        return Promise.resolve(true);
      }}));

      it('deletes the record', function() {
        expect($klass.isNew).to.eql(false);
        return $subject.then(data => {
          expect(data).to.be.a($Klass);
          expect(data.isNew).to.eql(true);
        });
      });

      context('when record is new', function() {
        beforeEach(function() {
          delete $klass.id;
        });

        it('does not change the record', function() {
          expect($klass.isNew).to.eql(true);
          return $subject.then(data => {
            expect(data).to.be.a($Klass);
            expect(data.isNew).to.eql(true);
          });
        });
      });
    });
  });

  describe('#reload()', function() {
    subject(() => $klass.reload());

    def('Klass', () => class Klass extends NextModel {
      static get schema() {
        return {
          id: { type: 'integer' },
          foo: { type: 'string' },
        };
      }

      static get connector() {
        return $connector;
      }
    });

    def('klass', () => {
      const klass = $Klass.build({ foo: 'foo' });
      klass.id = $id;
      return klass;
    });
    def('id', () => undefined);

    it('returns unchanged record as long as record is new', function() {
      return $subject.then(data => {
        expect(data).to.eql($klass);
      })
    });

    context('when record is persisted', function() {
      def('id', () => 1);

      it('throws error if connector is not overwritten', function() {
        expect(() => $subject).to.throwError();
      });

      context('when connector is present', function() {
        def('connector', () => ({ first: function(Klass) {
          return Promise.resolve($record);
        }}));

        context('when record is deleted', function() {
          def('record', () => undefined);

          it('flags record as new', function() {
            expect($klass.isNew).to.eql(false);

            return $subject.then(data => {
              expect(data).to.be.a($Klass);
              expect(data.isNew).to.eql(true);
              expect(data.foo).to.eql('foo');
            });
          });
        });

        context('when record is same', function() {
          def('record', () => $klass);

          it('does not change record', function() {
            return $subject.then(data => {
              expect(data).to.be.a($Klass);
              expect(data.id).to.eql($id);
              expect(data.foo).to.eql('foo');
            });
          });
        });

        context('when record has different values', function() {
          def('record', () => {
            const klass = $Klass.build({ foo: 'bar' });
            klass.id = $id;
            return klass;
          });

          it('updates values', function() {
            return $subject.then(data => {
              expect(data).to.be.a($Klass);
              expect(data.id).to.eql($id);
              expect(data.foo).to.eql('bar');
            });
          });
        });
      });
    });
  });
});
