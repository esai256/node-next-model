'use strict';

const NextModel = require('..');

const expect = require('expect.js');
const expectChange = require('expect-change');
const sinon = require('sinon');

const shared = require('./shared');

const lodash = require('lodash');
const filter = lodash.filter;
const first = lodash.first;
const keys = lodash.keys;
const last = lodash.last;
const orderBy = lodash.orderBy;

const mockConnector = function(data) {
  const all = (model) => {
    let result = filter(data, model.defaultScope);
    const order = model.defaultOrder;
    if (order) result = orderBy(result, keys(order), values(order));
    result = result.splice(model._skip, model._limit || Number.MAX_VALUE);
    return Promise.resolve(result);
  };
  const first = (model) => all(model).then(result => result[0]);
  const last = (model) => all(model).then(result => result[result.length - 1]);
  const count = (model) => all(model).then(result => result.length);
  const save = (model) => Promise.resolve(model.id = 1);
  return { all, first, last, count, save };
};

describe('NextModel', function() {
  // Static properties

  // - must be inherited

  describe('.modelName', function() {
    subject(() => $Klass.modelName);

    context('when modelName is present', function() {
      def('Klass', () => class Klass extends NextModel {
        static get modelName() {
          return 'foo';
        }
      });

      it('returns the name of the model', function() {
        expect($subject).to.eql('foo');
      });
    });

    context('when modelName is not present', function() {
      def('Klass', () => class Klass extends NextModel {});

      it('throws error if modelName is not overwritten', function() {
        expect(() => $subject).to.throwError();
      });
    });
  });

  describe('.schema', function() {
    subject(() => $Klass.schema);

    context('when schema is present', function() {
      def('Klass', () => class Klass extends NextModel {
        static get schema() {
          return {};
        }
      });

      it('returns the schema of the model', function() {
        expect($subject).to.eql({});
      });
    });

    context('when schema is not present', function() {
      def('Klass', () => class Klass extends NextModel {});

      it('throws error if schema is not overwritten', function() {
        expect(() => $subject).to.throwError();
      });
    });
  });

  describe('.connector', function() {
    subject(() => $Klass.connector);

    context('when connector is present', function() {
      def('Klass', () => class Klass extends NextModel {
        static get connector() {
          return 'foo';
        }
      });

      it('returns the connector', function() {
        expect($subject).to.eql('foo');
      });
    });

    context('when connector is not present', function() {
      def('Klass', () => class Klass extends NextModel {});

      it('throws error if connector is not overwritten', function() {
        expect(() => $subject).to.throwError();
      });
    });
  });

  // - optional

  describe('.identifier', function() {
    subject(() => $Klass.identifier);

    context('when value is not overwritten', function() {
      def('Klass', () => class Klass extends NextModel {});

      it('returns default value', function() {
        expect($subject).to.eql('id');
      });
    });
  });

  describe('.tableName', function() {
    subject(() => $Klass.tableName);

    context('when tableName is present', function() {
      def('Klass', () => class Klass extends NextModel {
        static get tableName() {
          return 'foo';
        }
      });

      it('returns the name of the table', function() {
        expect($subject).to.eql('foo');
      });
    });

    context('when modelName is present', function() {
      def('Klass', () => class Klass extends NextModel {
        static get modelName() {
          return 'foo';
        }
      });

      it('returns the plural name of the model', function() {
        expect($subject).to.eql('foos');
      });
    });

    context('when modelName is not present', function() {
      def('Klass', () => class Klass extends NextModel {});

      it('throws error if modelName is not overwritten', function() {
        expect(() => $subject).to.throwError();
      });
    });

    context('when connector is present', function() {
      def('connector', () => ({ tableName: () => 'foo' }));
      def('Klass', () => class Klass extends NextModel {
        static get connector() {
          return $connector;
        }

        static get modelName() {
          return 'Klass';
        }
      });

      it('return tableName generated by connector', function() {
        expect($subject).to.eql('foo');
      });

      context('when connector does not provide tableName function', function() {
        def('connector', () => ({ }));

        it('falls back to camelcase', function() {
          expect($subject).to.eql('klasses');
        });
      });
    });
  });

  describe('.attrAccessors', function() {
    subject(() => $Klass.attrAccessors);

    context('when value is not overwritten', function() {
      def('Klass', () => class Klass extends NextModel {});

      it('returns default value', function() {
        expect($subject).to.eql([]);
      });
    });
  });

  describe('.belongsTo', function() {
    subject(() => $Klass.belongsTo);

    context('when value is not overwritten', function() {
      def('Klass', () => class Klass extends NextModel {});

      it('returns default value', function() {
        expect($subject).to.eql({});
      });
    });
  });

  describe('.hasMany', function() {
    subject(() => $Klass.hasMany);

    context('when value is not overwritten', function() {
      def('Klass', () => class Klass extends NextModel {});

      it('returns default value', function() {
        expect($subject).to.eql({});
      });
    });
  });

  describe('.hasOne', function() {
    subject(() => $Klass.hasOne);

    context('when value is not overwritten', function() {
      def('Klass', () => class Klass extends NextModel {});

      it('returns default value', function() {
        expect($subject).to.eql({});
      });
    });
  });

  describe('.cacheData', function() {
    subject(() => $Klass.cacheData);

    context('when value is not overwritten', function() {
      def('Klass', () => class Klass extends NextModel {});

      it('returns default value', function() {
        expect($subject).to.eql(true);
      });
    });
  });

  describe('.defaultScope', function() {
    subject(() => $Klass.defaultScope);

    context('when value is not overwritten', function() {
      def('Klass', () => class Klass extends NextModel {});

      it('returns default value', function() {
        expect($subject).to.eql(undefined);
      });
    });
  });

  describe('.defaultOrder', function() {
    subject(() => $Klass.defaultOrder);

    context('when value is not overwritten', function() {
      def('Klass', () => class Klass extends NextModel {});

      it('returns default value', function() {
        expect($subject).to.eql(undefined);
      });
    });
  });

  // - computed

  describe('.keys', function() {
    subject(() => $Klass.keys);

    def('Klass', () => class Klass extends NextModel {
      static get schema() {
        return $schema;
      }

      static get attrAccessors() {
        return $attrAccessors;
      }
    });

    context('when schema is empty', function() {
      def('schema', () => ({}));

      it('returns empty array', function() {
        expect($subject).to.eql([]);
      });
    });

    context('when schema present', function() {
      def('schema', () => ({
        foo: { type: 'integer' },
      }));

      it('returns keys of schema', function() {
        expect($subject).to.eql(['foo']);
      });
    });

    context('when attrAccessors is present', function() {
      def('attrAccessors', () => ['foo']);

      it('returns keys from attrAccessors', function() {
        expect($subject).to.eql(['foo']);
      });
    });

    context('when schema and attrAccessors are present', function() {
      def('schema', () => ({
        foo: { type: 'integer' },
      }));
      def('attrAccessors', () => ['bar']);

      it('returns keys from attrAccessors', function() {
        expect($subject).to.have.length(2);
        expect($subject).to.contain('foo');
        expect($subject).to.contain('bar');
      });

      context('when both have same keys', function() {
        def('attrAccessors', () => ['foo']);

        it('returns overlapping keys once', function() {
          expect($subject).to.eql(['foo']);
        });
      });
    });
  });

  describe('.databaseKeys', function() {
    subject(() => $Klass.databaseKeys);

    def('Klass', () => class Klass extends NextModel {
      static get identifier() {
        return $identifier;
      }

      static get schema() {
        return $schema;
      }

      static get attrAccessors() {
        return $attrAccessors;
      }
    });

    context('when schema is empty', function() {
      def('schema', () => ({}));

      it('returns empty array', function() {
        expect($subject).to.eql([]);
      });
    });

    context('when schema present', function() {
      def('schema', () => ({
        foo: { type: 'integer' },
      }));

      it('returns keys of schema', function() {
        expect($subject).to.eql(['foo']);
      });

      context('when identifier is present', function() {
        def('identifier', () => 'id');

        it('returns keys of schema', function() {
          expect($subject).to.eql(['foo']);
        });
      });

      context('when identifier is in schema', function() {
        def('identifier', () => 'foo');

        it('returns keys without identifier', function() {
          expect($subject).to.eql([]);
        });
      });
    });

    context('when attrAccessors is present', function() {
      def('attrAccessors', () => ['foo']);

      it('returns no keys from attrAccessors', function() {
        expect($subject).to.eql([]);
      });
    });

    context('when schema and attrAccessors are present', function() {
      def('schema', () => ({
        foo: { type: 'integer' },
      }));
      def('attrAccessors', () => ['bar']);

      it('returns only keys from schema', function() {
        expect($subject).to.have.length(1);
        expect($subject).to.contain('foo');
      });

      context('when both have same keys', function() {
        def('attrAccessors', () => ['foo']);

          it('returns only keys from schema', function() {
          expect($subject).to.eql(['foo']);
        });
      });
    });
  });

  describe('.all', function() {
    subject(() => $Klass.all);

    def('Klass', () => class Klass extends NextModel {
      static get modelName() {
        return 'Klass';
      }

      static get schema() {
        return {
          id: { type: 'integer' },
          foo: { type: 'string' },
        };
      }

      static get defaultScope() {
        return $defaultScope;
      }

      static get defaultOrder() {
        return $defaultOrder;
      }
    });

    def('items', () => [
      { id: 1, foo: 'foo' },
      { id: 2, foo: 'foo' },
      { id: 3, foo: 'bar' },
      { id: 4, foo: 'bar' },
    ]);

    def('cache', () => [
      { id: 1, foo: 'foo' },
      { id: 2, foo: 'foo' },
    ]);

    it('throws error without connector', function () {
      expect(() => $subject).to.throwError();
    });

    context('when cache is present', function() {
      beforeEach(function() {
        $Klass.setCache('all', $cache);
      });

      it('returns cached data', function () {
        return $subject.then(data => expect(data).to.eql($cache));
      });

      context('when caching is disabled', function() {
        def('Klass', () => class Klass extends $Klass {
          static get cacheData() {
            return false;
          }
        });

        it('throws error without connector', function () {
          expect(() => $subject).to.throwError();
        });
      });
    });

    context('when connector is present', function() {
      def('Klass', () => class Klass extends $Klass {
        static get connector() {
          return mockConnector($items);
        }
      });

      it('returns queried data', function () {
        return $subject.then(data => expect(data).to.eql($items));
      });

      context('when cache is present', function() {
        beforeEach(function() {
          $Klass.setCache('all', $cache);
        });

        it('returns cached data', function () {
          return $subject.then(data => expect(data).to.eql($cache));
        });

        context('when caching is disabled', function() {
          def('Klass', () => class Klass extends $Klass {
            static get cacheData() {
              return false;
            }
          });

          it('returns queried data', function () {
            return $subject.then(data => expect(data).to.eql($items));
          });
        });
      });
    });
  });

  describe('.first', function() {
    subject(() => $Klass.first);

    def('Klass', () => class Klass extends NextModel {
      static get modelName() {
        return 'Klass';
      }

      static get schema() {
        return {
          id: { type: 'integer' },
          foo: { type: 'string' },
        };
      }

      static get defaultScope() {
        return $defaultScope;
      }

      static get defaultOrder() {
        return $defaultOrder;
      }
    });

    def('items', () => [
      { id: 1, foo: 'foo' },
      { id: 2, foo: 'foo' },
      { id: 3, foo: 'bar' },
      { id: 4, foo: 'bar' },
    ]);

    def('cache', () => ({ id: 2, foo: 'foo' }));

    it('throws error without connector', function () {
      expect(() => $subject).to.throwError();
    });

    context('when cache is present', function() {
      beforeEach(function() {
        $Klass.setCache('first', $cache);
      });

      it('returns cached data', function () {
        return $subject.then(data => expect(data).to.eql($cache));
      });

      context('when caching is disabled', function() {
        def('Klass', () => class Klass extends $Klass {
          static get cacheData() {
            return false;
          }
        });

        it('throws error without connector', function () {
          expect(() => $subject).to.throwError();
        });
      });
    });

    context('when connector is present', function() {
      def('Klass', () => class Klass extends $Klass {
        static get connector() {
          return mockConnector($items);
        }
      });

      it('returns queried data', function () {
        return $subject.then(data => expect(data).to.eql(first($items)));
      });

      context('when cache is present', function() {
        beforeEach(function() {
          $Klass.setCache('first', $cache);
        });

        it('returns cached data', function () {
          return $subject.then(data => expect(data).to.eql($cache));
        });

        context('when caching is disabled', function() {
          def('Klass', () => class Klass extends $Klass {
            static get cacheData() {
              return false;
            }
          });

          it('returns queried data', function () {
            return $subject.then(data => expect(data).to.eql(first($items)));
          });
        });
      });
    });
  });

  describe('.last', function() {
    subject(() => $Klass.last);

    def('Klass', () => class Klass extends NextModel {
      static get modelName() {
        return 'Klass';
      }

      static get schema() {
        return {
          id: { type: 'integer' },
          foo: { type: 'string' },
        };
      }

      static get defaultScope() {
        return $defaultScope;
      }

      static get defaultOrder() {
        return $defaultOrder;
      }
    });

    def('items', () => [
      { id: 1, foo: 'foo' },
      { id: 2, foo: 'foo' },
      { id: 3, foo: 'bar' },
      { id: 4, foo: 'bar' },
    ]);

    def('cache', () => ({ id: 2, foo: 'foo' }));

    it('throws error without connector', function () {
      expect(() => $subject).to.throwError();
    });

    context('when cache is present', function() {
      beforeEach(function() {
        $Klass.setCache('last', $cache);
      });

      it('returns cached data', function () {
        return $subject.then(data => expect(data).to.eql($cache));
      });

      context('when caching is disabled', function() {
        def('Klass', () => class Klass extends $Klass {
          static get cacheData() {
            return false;
          }
        });

        it('throws error without connector', function () {
          expect(() => $subject).to.throwError();
        });
      });
    });

    context('when connector is present', function() {
      def('Klass', () => class Klass extends $Klass {
        static get connector() {
          return mockConnector($items);
        }
      });

      it('returns queried data', function () {
        return $subject.then(data => expect(data).to.eql(last($items)));
      });

      context('when cache is present', function() {
        beforeEach(function() {
          $Klass.setCache('last', $cache);
        });

        it('returns cached data', function () {
          return $subject.then(data => expect(data).to.eql($cache));
        });

        context('when caching is disabled', function() {
          def('Klass', () => class Klass extends $Klass {
            static get cacheData() {
              return false;
            }
          });

          it('returns queried data', function () {
            return $subject.then(data => expect(data).to.eql(last($items)));
          });
        });
      });
    });
  });

  describe('.count', function() {
    subject(() => $Klass.count);

    def('Klass', () => class Klass extends NextModel {
      static get modelName() {
        return 'Klass';
      }

      static get schema() {
        return {
          id: { type: 'integer' },
          foo: { type: 'string' },
        };
      }

      static get defaultScope() {
        return $defaultScope;
      }

      static get defaultOrder() {
        return $defaultOrder;
      }
    });

    def('items', () => [
      { id: 1, foo: 'foo' },
      { id: 2, foo: 'foo' },
      { id: 3, foo: 'bar' },
      { id: 4, foo: 'bar' },
    ]);

    def('cache', () => 2);

    it('throws error without connector', function () {
      expect(() => $subject).to.throwError();
    });

    context('when cache is present', function() {
      beforeEach(function() {
        $Klass.setCache('count', $cache);
      });

      it('returns cached data', function () {
        return $subject.then(data => expect(data).to.eql($cache));
      });

      context('when caching is disabled', function() {
        def('Klass', () => class Klass extends $Klass {
          static get cacheData() {
            return false;
          }
        });

        it('throws error without connector', function () {
          expect(() => $subject).to.throwError();
        });
      });
    });

    context('when connector is present', function() {
      def('Klass', () => class Klass extends $Klass {
        static get connector() {
          return mockConnector($items);
        }
      });

      it('returns queried data', function () {
        return $subject.then(data => expect(data).to.eql($items.length));
      });

      context('when cache is present', function() {
        beforeEach(function() {
          $Klass.setCache('count', $cache);
        });

        it('returns cached data', function () {
          return $subject.then(data => expect(data).to.eql($cache));
        });

        context('when caching is disabled', function() {
          def('Klass', () => class Klass extends $Klass {
            static get cacheData() {
              return false;
            }
          });

          it('returns queried data', function () {
            return $subject.then(data => expect(data).to.eql($items.length));
          });
        });
      });
    });
  });

  describe('.model', function() {
    subject(() => $Klass.model);

    def('Klass', () => class Klass extends NextModel {
      static get modelName() {
        return 'Klass';
      }

      static get schema() {
        return {
          id: { type: 'integer' },
          foo: { type: 'string' },
        };
      }

      static get defaultScope() {
        return $defaultScope;
      }

      static get defaultOrder() {
        return $defaultOrder;
      }
    });

    it('ruturns a NextModel', function() {
      expect($subject).to.be.a('function');
      expect($subject.modelName).to.eql('Klass');
    });

    context('cache is present', function() {
      beforeEach(function() {
        $Klass.cache = [{ foo: 1 }];
      });

      it('clears cache', function() {
        expect($subject.cache).to.eql(undefined);
      });
    });

    context('defaultScope is present', function() {
      def('defaultScope', () => ({ foo: 1 }));

      it('sets scope to undefined', function() {
        expect($subject.defaultScope).to.eql(undefined);
      });
    });

    context('defaultOrder is present', function() {
      def('defaultOrder', () => ({ foo: 'asc' }));

      it('sets order to undefined', function() {
        expect($subject.defaultOrder).to.eql(undefined);
      });
    });
  });

  describe('.withoutScope', function() {
    subject(() => $Klass.withoutScope);

    def('Klass', () => class Klass extends NextModel {
      static get modelName() {
        return 'Klass';
      }

      static get schema() {
        return {
          id: { type: 'integer' },
          foo: { type: 'string' },
        };
      }

      static get defaultScope() {
        return $defaultScope;
      }

      static get defaultOrder() {
        return $defaultOrder;
      }
    });

    it('ruturns a NextModel', function() {
      expect($subject).to.be.a('function');
      expect($subject.modelName).to.eql('Klass');
    });

    context('cache is present', function() {
      beforeEach(function() {
        $Klass.cache = [{ foo: 1 }];
      });

      it('clears cache', function() {
        expect($subject.cache).to.eql(undefined);
      });
    });

    context('defaultScope is present', function() {
      def('defaultScope', () => ({ foo: 1 }));

      it('sets scope to undefined', function() {
        expect($subject.defaultScope).to.eql(undefined);
      });
    });

    context('defaultOrder is present', function() {
      def('defaultOrder', () => ({ foo: 'asc' }));

      it('keeps order', function() {
        expect($subject.defaultOrder).to.eql({ foo: 'asc' });
      });
    });
  });

  describe('.unorder', function() {
    subject(() => $Klass.unorder);

    def('Klass', () => class Klass extends NextModel {
      static get modelName() {
        return 'Klass';
      }

      static get schema() {
        return {
          id: { type: 'integer' },
          foo: { type: 'string' },
        };
      }

      static get defaultScope() {
        return $defaultScope;
      }

      static get defaultOrder() {
        return $defaultOrder;
      }
    });


    it('ruturns a NextModel', function() {
      expect($subject).to.be.a('function');
      expect($subject.modelName).to.eql('Klass');
    });

    context('cache is present', function() {
      beforeEach(function() {
        $Klass.cache = [{ foo: 1 }];
      });

      it('clears cache', function() {
        expect($subject.cache).to.eql(undefined);
      });
    });

    context('defaultScope is present', function() {
      def('defaultScope', () => ({ foo: 1 }));

      it('keeps default scope', function() {
        expect($subject.defaultScope).to.eql({ foo: 1 });
      });
    });

    context('defaultOrder is present', function() {
      def('defaultOrder', () => ({ foo: 'asc' }));

      it('sets order to undefined', function() {
        expect($subject.defaultOrder).to.eql(undefined);
      });
    });
  });

  describe('.reload', function() {
    subject(() => $Klass.reload);

    def('Klass', () => class Klass extends NextModel {
      static get modelName() {
        return 'Klass';
      }

      static get schema() {
        return {
          id: { type: 'integer' },
          foo: { type: 'string' },
        };
      }

      static get defaultScope() {
        return $defaultScope;
      }

      static get defaultOrder() {
        return $defaultOrder;
      }
    });

    it('ruturns a NextModel', function() {
      expect($subject).to.be.a('function');
      expect($subject.modelName).to.eql('Klass');
    });

    context('cache is present', function() {
      def('queryType', () => 'all');
      def('items', () => [{ foo: 1 }]);

      beforeEach(function() {
        $Klass.setCache($queryType, $items);
      });

      it('clears cache', function() {
        expect($Klass.getCache($queryType)).eql($items);
        expect($subject.getCache($queryType)).to.eql(undefined);
      });
    });

    context('defaultScope is present', function() {
      def('defaultScope', () => ({ foo: 1 }));

      it('keeps scope', function() {
        expect($subject.defaultScope).to.eql({ foo: 1 });
      });
    });

    context('defaultOrder is present', function() {
      def('defaultOrder', () => ({ foo: 'asc' }));

      it('keeps order', function() {
        expect($subject.defaultOrder).to.eql({ foo: 'asc' });
      });
    });
  });

  // Static functions

  describe('.hasCache()', function() {
    subject(() => $Klass.hasCache($queryType));
    def('Klass', () => class Klass extends NextModel {});

    def('queryType', () => 'all');

    it('returns false', function() {
      expect($subject).to.eql(false);
    });

    context('when other querytype is set', function() {
      beforeEach(function() {
        $Klass.setCache('first', { foo: 'bar' });
      });

      it('returns false', function() {
        expect($subject).to.eql(false);
      });
    });

    context('when other cache is set', function() {
      beforeEach(function() {
        $Klass.setCache('all', [{ foo: 'bar' }]);
      });

      it('returns true', function() {
        expect($subject).to.eql(true);
      });

      context('when cacheData is disabled', function() {
        def('Klass', () => class Klass extends $Klass {
          static get cacheData() {
            return false;
          }
        });

        it('returns false', function () {
          expect($subject).to.eql(false);
        });
      });
    });
  });

  describe('.getCache()', function() {
    subject(() => $Klass.getCache($queryType));
    def('Klass', () => class Klass extends NextModel {});

    context('when queryType is all', function() {
      def('queryType', () => 'all');

      it('returns undefined', function() {
        expect($subject).to.eql(undefined);
      });

      context('when cache is set', function() {
        beforeEach(function() {
          $Klass.setCache('all', [{ foo: 'bar' }]);
        });

        it('returns cached items', function() {
          expect($subject).to.eql([{ foo: 'bar' }]);
        });
      });
    });

    context('when queryType is first', function() {
      def('queryType', () => 'first');

      it('returns undefined', function() {
        expect($subject).to.eql(undefined);
      });

      context('when cache is set', function() {
        beforeEach(function() {
          $Klass.setCache('first', { foo: 'bar' });
        });

        it('returns cached item', function() {
          expect($subject).to.eql({ foo: 'bar' });
        });
      });
    });
  });

  describe('.setCache()', function() {
    subject(() => $Klass.setCache($queryType, $value));
    def('Klass', () => class Klass extends NextModel {});
    def('queryType', () => 'all');
    def('value', () => ({ foo: 'bar' }));

    it('sets and unsets cache', function() {
      const cache = () => $Klass.getCache($queryType);
      expect(() => $subject).to
        .change(cache).from(undefined).to($value);
      expect(() => $Klass.setCache($queryType, undefined)).to
        .change(cache).from($value).to(undefined);
      expect($subject).to.eql($value);
    });
  });

  describe('.build()', function() {
    subject(() => $Klass.build($attrs));

    def('schema', () => ({}));

    def('Klass', () => class Klass extends NextModel {
      static get modelName() {
        return 'Klass';
      }

      static get schema() {
        return $schema;
      }

      static get attrAccessors() {
        return $attrAccessors;
      }
    });

    it('returns model instance', function() {
      expect($subject).to.be.a($Klass);
    });

    context('when schema is present', function() {
      def('schema', () => ({
        id: { type: 'integer' },
        bar: { type: 'string', defaultValue: 'bar' },
      }));

      it('returns model instance and sets default values', function() {
        expect($subject).to.be.a($Klass);
        expect($subject.id).to.eql(null);
        expect($subject.bar).to.eql('bar');
      });

      context('when passing attributes to constructor', function() {
        def('attrs', () => ({
          bar: 'foo',
        }));

        it('returns model instance and sets attributes', function() {
          expect($subject).to.be.a($Klass);
          expect($subject.id).to.eql(null);
          expect($subject.bar).to.eql('foo');
        });

        context('when passing id', function() {
          def('attrs', () => ({
            id: 1,
            bar: 'foo',
          }));

          it('throws error while creating', function() {
            expect(() => $subject).to.throwError();
          });
        });
      });

      context('when passing invalid attributes to constructor', function() {
        def('attrs', () => ({
          baz: 'foo',
        }));

        it('throws error while creating', function() {
          expect(() => $subject).to.throwError();
        });
      });

      context('when attrAccessors are present', function() {
        def('attrAccessors', () => ['baz']);

        it('does not set accessor', function() {
          expect($subject).to.be.a($Klass);
          expect($subject.baz).to.eql(undefined);
        });

        context('when passing attributes to constructor', function() {
          def('attrs', () => ({
            baz: 'foo',
          }));

          it('returns model instance and sets attributes', function() {
            expect($subject).to.be.a($Klass);
            expect($subject.baz).to.eql('foo');
          });
        });
      });
    });
  });

  describe('.promiseBuild()', function() {
    subject(() => $Klass.promiseBuild($attrs));

    def('schema', () => ({}));

    def('Klass', () => class Klass extends NextModel {
      static get modelName() {
        return 'Klass';
      }

      static get schema() {
        return $schema;
      }

      static get attrAccessors() {
        return $attrAccessors;
      }
    });

    def('klass', () => new $Klass());

    it('returns model instance', function() {
      return $subject.then(data => {
        expect(data).to.be.a($Klass);
      });
    });

    shared.behavesLikeActionWhichSupportsCallbacks({
      action: 'build',
      actionIsStatic: true,
      actionIsPromise: true,
      innerActionBase: 'Klass',
    });

    context('when schema is present', function() {
      def('schema', () => ({
        id: { type: 'integer' },
        bar: { type: 'string', defaultValue: 'bar' },
      }));

      it('returns model instance and sets default values', function() {
        return $subject.then(data => {
          expect(data).to.be.a($Klass);
          expect(data.id).to.eql(null);
          expect(data.bar).to.eql('bar');
        });
      });

      context('when passing attributes to constructor', function() {
        def('attrs', () => ({
          bar: 'foo',
        }));

        it('returns model instance and sets attributes', function() {
          return $subject.then(data => {
            expect(data).to.be.a($Klass);
            expect(data.id).to.eql(null);
            expect(data.bar).to.eql('foo');
          });
        });

        context('when passing id', function() {
          def('attrs', () => ({
            id: 1,
            bar: 'foo',
          }));

          it('catches promise reject', shared.promiseError);
        });
      });

      context('when passing invalid attributes to constructor', function() {
        def('attrs', () => ({
          baz: 'foo',
        }));

        it('catches promise reject', shared.promiseError);
      });

      context('when attrAccessors are present', function() {
        def('attrAccessors', () => ['baz']);

        it('does not set accessor', function() {
          return $subject.then(data => {
            expect(data).to.be.a($Klass);
            expect(data.baz).to.eql(undefined);
          });
        });

        context('when passing attributes to constructor', function() {
          def('attrs', () => ({
            baz: 'foo',
          }));

          it('returns model instance and sets attributes', function() {
            return $subject.then(data => {
              expect(data).to.be.a($Klass);
              expect(data.baz).to.eql('foo');
            });
          });
        });
      });
    });
  });

  describe('.create()', function() {
    subject(() => $Klass.create($attrs));

    def('schema', () => ({}));

    def('connector', () => ({ save: function(klass) {
      klass.id = 1;
      return Promise.resolve(true);
    }}));

    def('Klass', () => class Klass extends NextModel {
      static get connector() {
        return $connector;
      }

      static get modelName() {
        return 'Klass';
      }

      static get schema() {
        return $schema;
      }

      static get attrAccessors() {
        return $attrAccessors;
      }
    });

    def('klass', () => new $Klass());

    shared.behavesLikeActionWhichSupportsCallbacks({
      action: 'build',
      actionIsStatic: true,
      actionIsPromise: true,
      innerActionBase: 'Klass',
    });

    shared.behavesLikeActionWhichSupportsCallbacks({
      action: 'create',
      actionIsStatic: true,
      actionIsPromise: true,
      innerActionBase: 'Klass',
      innerActionName: 'promiseBuild',
    });

    context('when promiseBuild returns $klass', function() {
      beforeEach(function() {
        sinon.stub($Klass, 'promiseBuild').returns(Promise.resolve($klass));
      });

      shared.behavesLikeActionWhichSupportsCallbacks({
        action: 'save',
        actionIsPromise: true,
      });
    });

    it('returns model instance', function() {
      return $subject.then(data => expect(data).to.be.a($Klass));
    });

    context('when schema is present', function() {
      def('schema', () => ({
        id: { type: 'integer' },
        bar: { type: 'string', defaultValue: 'bar' },
      }));

      it('returns model instance and sets default values', function() {
        return $subject.then(data => {
          expect(data).to.be.a($Klass);
          expect(data.id).to.eql(1);
          expect(data.bar).to.eql('bar');
        });
      });

      context('when passing attributes to constructor', function() {
        def('attrs', () => ({
          bar: 'foo',
        }));

        it('returns model instance and sets attributes', function() {
          return $subject.then(data => {
            expect(data).to.be.a($Klass);
            expect(data.id).to.eql(1);
            expect(data.bar).to.eql('foo');
          });
        });

        context('when passing id', function() {
          def('attrs', () => ({
            id: 1,
            bar: 'foo',
          }));

          it('catches promise reject', shared.promiseError);
        });
      });

      context('when passing invalid attributes to constructor', function() {
        def('attrs', () => ({
          baz: 'foo',
        }));

        it('catches promise reject', shared.promiseError);
      });

      context('when attrAccessors are present', function() {
        def('attrAccessors', () => ['baz']);

        it('does not set accessor', function() {
          return $subject.then(data => {
            expect(data).to.be.a($Klass);
            expect(data.baz).to.eql(undefined);
          });
        });

        context('when passing attributes to constructor', function() {
          def('attrs', () => ({
            baz: 'foo',
          }));

          it('returns model instance and sets attributes', function() {
            return $subject.then(data => {
              expect(data).to.be.a($Klass);
              expect(data.baz).to.eql('foo');
            });
          });
        });
      });
    });
  });

  describe('.limit()', function() {
    subject(() => $Klass.limit($amount));

    def('Klass', () => class Klass extends NextModel {
      static get modelName() {
        return 'Klass';
      }

      static get schema() {
        return {
          id: { type: 'integer' },
          foo: { type: 'string' },
        };
      }

      static get defaultScope() {
        return $defaultScope;
      }

      static get connector() {
        return mockConnector($items);
      }
    });

    def('items', () => [
      { id: 1, foo: 'foo' },
      { id: 2, foo: 'foo' },
      { id: 3, foo: 'bar' },
      { id: 4, foo: 'bar' },
    ]);

    context('when limit is a number', function () {
      def('amount', () => 1);

      it('throws no error', function () {
        expect(() => $subject).to.not.throwError();
      });
    });


    context('when limit is no number', function () {
      def('amount', () => 'a');

      it('throws error', function () {
        expect(() => $subject).to.throwError();
      });
    });

    context('when limit below 0', function () {
      def('amount', () => -1);

      it('throws error', function () {
        expect(() => $subject).to.throwError();
      });
    });

    context('when fetching items', function() {
      subject(() => $Klass.limit($amount).all);

      context('when limit is heigher than item count' , function() {
        def('amount', () => 10);

        it('returns all items', function () {
          return $subject.then(data => expect(data).to.eql($items));
        });
      });

      context('when limit is lower than item count' , function() {
        def('amount', () => 2);

        it('takes the items from start', function () {
          return $subject.then(data => expect(data).to.eql([$items[0], $items[1]]));
        });
      });

      context('when defaultScope present', function() {
        def('amount', () => 1);
        def('defaultScope', () => ({ foo: 'bar' }));

        it('limits matching items', function () {
          return $subject.then(data => expect(data).to.eql([$items[2]]));
        });
      });
    });
  });

  describe('.unlimit()', function() {
    subject(() => $Klass.unlimit().all);

    def('Klass', () => class Klass extends NextModel {
      static get modelName() {
        return 'Klass';
      }

      static get schema() {
        return {
          id: { type: 'integer' },
          foo: { type: 'string' },
        };
      }

      static get defaultScope() {
        return $defaultScope;
      }

      static get connector() {
        return mockConnector($items);
      }
    });

    def('items', () => [
      { id: 1, foo: 'foo' },
      { id: 2, foo: 'foo' },
      { id: 3, foo: 'bar' },
      { id: 4, foo: 'bar' },
    ]);

    it('returns all items', function () {
      return $subject.then(data => expect(data).to.eql($items));
    });

    context('when limit is present' , function() {
      def('Klass', () => $Klass.limit(1));

      it('returns all items', function () {
        return $subject.then(data => expect(data).to.eql($items));
      });
    });
  });

  describe('.skip()', function() {
    subject(() => $Klass.skip($amount));

    def('Klass', () => class Klass extends NextModel {
      static get modelName() {
        return 'Klass';
      }

      static get schema() {
        return {
          id: { type: 'integer' },
          foo: { type: 'string' },
        };
      }

      static get defaultScope() {
        return $defaultScope;
      }

      static get connector() {
        return mockConnector($items);
      }
    });

    def('items', () => [
      { id: 1, foo: 'foo' },
      { id: 2, foo: 'foo' },
      { id: 3, foo: 'bar' },
      { id: 4, foo: 'bar' },
    ]);

    context('when skip is a number', function () {
      def('amount', () => 1);

      it('throws no error', function () {
        expect(() => $subject).to.not.throwError();
      });
    });


    context('when skip is no number', function () {
      def('amount', () => 'a');

      it('throws error', function () {
        expect(() => $subject).to.throwError();
      });
    });

    context('when skip below 0', function () {
      def('amount', () => -1);

      it('throws error', function () {
        expect(() => $subject).to.throwError();
      });
    });

    context('when fetching items', function() {
      subject(() => $Klass.skip($amount).all);

      context('when skip is heigher than item count', function() {
        def('amount', () => 10);

        it('returns no items', function () {
          return $subject.then(data => expect(data).to.eql([]));
        });
      });

      context('when skip is lower than item count' , function() {
        def('amount', () => 2);

        it('skips the items from start', function () {
          return $subject.then(data => expect(data).to.eql([$items[2], $items[3]]));
        });
      });

      context('when defaultScope present', function() {
        def('amount', () => 1);
        def('defaultScope', () => ({ foo: 'bar' }));

        it('skips matching items', function () {
          return $subject.then(data => expect(data).to.eql([$items[3]]));
        });
      });
    });
  });

  describe('.unskip()', function() {
    subject(() => $Klass.unskip().all);

    def('Klass', () => class Klass extends NextModel {
      static get modelName() {
        return 'Klass';
      }

      static get schema() {
        return {
          id: { type: 'integer' },
          foo: { type: 'string' },
        };
      }

      static get defaultScope() {
        return $defaultScope;
      }

      static get connector() {
        return mockConnector($items);
      }
    });

    def('items', () => [
      { id: 1, foo: 'foo' },
      { id: 2, foo: 'foo' },
      { id: 3, foo: 'bar' },
      { id: 4, foo: 'bar' },
    ]);

    it('returns all items', function () {
      return $subject.then(data => expect(data).to.eql($items));
    });

    context('when skip is present' , function() {
      def('Klass', () => $Klass.skip(1));

      it('returns all items', function () {
        return $subject.then(data => expect(data).to.eql($items));
      });
    });
  });

  describe('.withScope()', function() {
    subject(() => $Klass.withScope($scope));
    def('scope', () => ({ foo: 'bar' }));

    def('Klass', () => class Klass extends NextModel {
      static get modelName() {
        return 'Klass';
      }

      static get schema() {
        return {
          foo: { type: 'integer' },
          bar: { type: 'integer' },
        };
      }

      static get defaultScope() {
        return $defaultScope;
      }
    });

    it('ruturns a NextModel', function() {
      expect($subject).to.be.a('function');
      expect($subject.modelName).to.eql('Klass');
    });

    it('passes scope to defaultScope', function() {
      expect($subject.defaultScope).to.eql($scope);
    });

    context('defaultScope is already present', function() {
      def('defaultScope', () => ({ bar: 'baz' }));

      it('overrides current scope', function() {
        expect($subject.defaultScope).to.eql($scope);
      });

      context('defaultScope is already present with same key', function() {
        def('defaultScope', () => ({ foo: 'baz' }));

        it('overrides current scope', function() {
          expect($subject.defaultScope).to.eql($scope);
        });
      });
    });
  });

  describe('.order()', function() {
    subject(() => $Klass.order($order));
    def('order', () => ({ foo: 'asc' }));

    def('Klass', () => class Klass extends NextModel {
      static get modelName() {
        return 'Klass';
      }

      static get schema() {
        return {
          foo: { type: 'integer' },
          bar: { type: 'integer' },
        };
      }

      static get defaultOrder() {
        return $defaultOrder;
      }
    });

    it('ruturns a NextModel', function() {
      expect($subject).to.be.a('function');
      expect($subject.modelName).to.eql('Klass');
    });

    it('passes order to defaultOrder', function() {
      expect($subject.defaultOrder).to.eql($order);
    });

    context('when value is invalid', function() {
      def('order', () => ({ foo: 1 }));

      it('throws error', function() {
        expect(() => $subject).to.throwError();
      });
    });

    context('when key is not in schema', function() {
      def('order', () => ({ baz: 'asc' }));

      it('throws error', function() {
        expect(() => $subject).to.throwError();
      });
    });

    context('defaultOrder is already present', function() {
      def('defaultOrder', () => ({ bar: 'desc' }));

      it('overrides current order', function() {
        expect($subject.defaultOrder).to.eql($order);
      });

      context('defaultOrder is already present with same key', function() {
        def('defaultOrder', () => ({ foo: 'desc' }));

        it('overrides current order', function() {
          expect($subject.defaultOrder).to.eql($order);
        });
      });
    });
  });

  describe('.scope()', function() {
    subject(() => $Klass.scope({ where: $scope }));
    def('scope', () => ({ foo: 'bar' }));

    def('Klass', () => class Klass extends NextModel {
      static get modelName() {
        return 'Klass';
      }

      static get schema() {
        return {
          foo: { type: 'integer' },
          bar: { type: 'integer' },
        };
      }

      static get defaultScope() {
        return $defaultScope;
      }
    });

    it('ruturns a NextModel', function() {
      expect($subject).to.be.a('function');
      expect($subject.modelName).to.eql('Klass');
    });

    it('passes scope to defaultScope', function() {
      expect($subject.defaultScope).to.eql({ foo: 'bar' });
    });

    context('defaultScope is already present', function() {
      def('defaultScope', () => ({ bar: 'baz' }));

      it('merges current scope', function() {
        expect($subject.defaultScope).to.eql(
          { $and: [{ bar: 'baz' }, { foo: 'bar' }] }
        );
      });
    });
  });

  describe('.unscope()', function() {
    subject(() => $Klass.unscope($args));
    def('args', () => 'foo');
    def('defaultScope', () => ({ foo : 1 }));

    def('Klass', () => class Klass extends NextModel {
      static get modelName() {
        return 'Klass';
      }

      static get schema() {
        return {
          foo: { type: 'integer' },
          bar: { type: 'integer' },
        };
      }

      static get defaultScope() {
        return $defaultScope;
      }
    });

    it('ruturns a NextModel', function() {
      expect($subject).to.be.a('function');
      expect($subject.modelName).to.eql('Klass');
    });

    it('removes scope from defaultScope', function() {
      expect($Klass.defaultScope).to.eql($defaultScope);
      expect($subject.defaultScope).to.eql({ });
    });

    context('when key is not in schema', function() {
      def('args', () => 'baz');

      it('does not change the defaultScope', function() {
        expect($subject.defaultScope).to.eql($defaultScope);
      });
    });

    context('defaultScope has multiple attributes', function() {
      def('defaultScope', () => ({ foo: 1, bar: 2 }));

      it('just removes one property of scope', function() {
        expect($subject.defaultScope).to.eql({ bar: 2 });
      });

      context('when unscoping multiple properties', function() {
        def('args', () => ['foo', 'bar']);

        it('removed all properties by key', function() {
          expect($subject.defaultScope).to.eql({ });
        });
      });
    });
  });

  describe('.where()', function() {
    subject(() => $Klass.where($scope));
    def('scope', () => ({ foo: 'bar' }));

    def('Klass', () => class Klass extends NextModel {
      static get modelName() {
        return 'Klass';
      }

      static get schema() {
        return {
          foo: { type: 'integer' },
          bar: { type: 'integer' },
        };
      }

      static get defaultScope() {
        return $defaultScope;
      }
    });

    it('ruturns a NextModel', function() {
      expect($subject).to.be.a('function');
      expect($subject.modelName).to.eql('Klass');
    });

    it('passes scope to defaultScope', function() {
      expect($subject.defaultScope).to.eql({ foo: 'bar' });
    });

    context('defaultScope is already present', function() {
      def('defaultScope', () => ({ bar: 'baz' }));

      it('merges current scope', function() {
        expect($subject.defaultScope).to.eql(
          { $and: [{ bar: 'baz' }, { foo: 'bar' }] }
        );
      });
    });
  });

  describe('.orWhere()', function() {
    subject(() => $Klass.orWhere($scope));
    def('scope', () => ({ foo: 'bar' }));

    def('Klass', () => class Klass extends NextModel {
      static get modelName() {
        return 'Klass';
      }

      static get schema() {
        return {
          foo: { type: 'integer' },
          bar: { type: 'integer' },
        };
      }

      static get defaultScope() {
        return $defaultScope;
      }
    });

    it('ruturns a NextModel', function() {
      expect($subject).to.be.a('function');
      expect($subject.modelName).to.eql('Klass');
    });

    it('passes scope to defaultScope', function() {
      expect($subject.defaultScope).to.eql({ foo: 'bar' });
    });

    context('defaultScope is already present', function() {
      def('defaultScope', () => ({ bar: 'baz' }));

      it('merges current scope', function() {
        expect($subject.defaultScope).to.eql(
          { $or: [{ bar: 'baz' }, { foo: 'bar' }] }
        );
      });
    });
  });

  describe('.createTable()', function() {
    subject(() => $Klass.createTable());

    context('when connector is present', function() {
      def('Klass', () => class Klass extends NextModel {
        static get connector() {
          return { createTable: function(Klass) {
            return Promise.resolve('called');
          }};
        }
      });

      it('calls the createTable function of the connector', function() {
        return $subject.then(data => expect(data).to.eql('called'));
      });
    });

    context('when connector is not present', function() {
      def('Klass', () => class Klass extends NextModel {});

      it('throws error if connector is not overwritten', function() {
        expect(() => $subject).to.throwError();
      });
    });
  });

  describe('.fetchSchema()', function() {
    subject(() => $Klass.fetchSchema());

    def('Klass', () => class Klass extends NextModel {
      static get modelName() {
        return 'Klass';
      }

      static get schema() {
        return $schema;
      }

      static get belongsTo() {
        return $belongsTo;
      }
    });

    it('returns empty schema', function() {
      expect($subject).to.eql({});
    });

    context('when schema is present', function() {
      def('schema', () => ({
        foo: { type: 'integer', defaultValue: 1 },
        bar: { type: 'integer', defaultValue: 2 },
      }));

      it('returns schema', function() {
        expect($subject).to.eql({
          foo: { type: 'integer', defaultValue: 1 },
          bar: { type: 'integer', defaultValue: 2 },
        });
      });
    });

    context('when type is not present', function() {
      def('schema', () => ({
        foo: { defaultValue: 'foo' },
        bar: { type: 'integer', defaultValue: 2 },
      }));

      it('adds type string if no type is present', function() {
        expect($subject).to.eql({
          foo: { type: 'string', defaultValue: 'foo' },
          bar: { type: 'integer', defaultValue: 2 },
        });
      });
    });

    context('when defaultValue is not present', function() {
      def('schema', () => ({
        foo: { type: 'integer' },
        bar: { type: 'integer', defaultValue: 2 },
      }));

      it('adds type string if no type is present', function() {
        expect($subject).to.eql({
          foo: {type: 'integer', defaultValue: null},
          bar: {type: 'integer', defaultValue: 2},
        });
      });
    });

    context('when belongsTo relation is present', function() {
      def('Foo', () => class Foo extends NextModel {
        static get modelName() {
          return 'Foo';
        }

        static get schema() {
          return {
            id: { type: 'integer' },
          };
        }
      });

      def('belongsTo', () => ({
        foo: { model: $Foo },
      }));

      it('adds join column to schema', function() {
        expect($subject).to.eql({ fooId: { type: 'integer', defaultValue: null }});
      });

      context('when belongsTo relation has foreignKey', function() {
        def('belongsTo', () => ({
          foo: { model: $Foo, foreignKey: 'baz' },
        }));

        it('adds join column to schema', function() {
          expect($subject).to.eql({ baz: { type: 'integer', defaultValue: null }});
        });
      });
    });

    context('when belongsTo relation class has identifier', function() {
      def('Foo', () => class Foo extends NextModel {
        static get modelName() {
          return 'Foo';
        }

        static get schema() {
          return {
            guid: { type: 'guid' },
          };
        }

        static get identifier() {
          return 'guid';
        }
      });

      def('belongsTo', () => ({
        foo: { model: $Foo },
      }));

      it('used identifier column as reverse lookup', function() {
        expect($subject).to.eql({ fooId: { type: 'guid', defaultValue: null }});
      });
    });

    context('when belongsTo relation class has defaultValue', function() {
      def('Foo', () => class Foo extends NextModel {
        static get modelName() {
          return 'Foo';
        }

        static get schema() {
          return {
            id: { type: 'integer', defaultValue: 0 },
          };
        }
      });

      def('belongsTo', () => ({
        foo: { model: $Foo },
      }));

      it('adds join column to schema', function() {
        expect($subject).to.eql({ fooId: { type: 'integer', defaultValue: 0 }});
      });
    });
  });

  describe('.fetchBelongsTo()', function() {
    subject(() => $Klass.fetchBelongsTo());

    def('Klass', () => class Klass extends NextModel {
      static get modelName() {
        return 'Klass';
      }

      static get belongsTo() {
        return {
          foo: { model: $Foo },
          bar: { model: $Foo, foreignKey: 'bazId' },
        };
      }
    });

    def('Foo', () => class Foo extends NextModel {
      static get modelName() {
        return 'Foo';
      }
    });

    it('prefills foreignKey if foreignKey is not present', function() {
      expect($subject).to.eql({
        foo: { model: $Foo, foreignKey: 'fooId' },
        bar: { model: $Foo, foreignKey: 'bazId' },
      });
    });
  });

  describe('.fetchHasMany()', function() {
    subject(() => $Klass.fetchHasMany());

    def('Klass', () => class Klass extends NextModel {
      static get modelName() {
        return 'Klass';
      }

      static get hasMany() {
        return {
          foo: { model: $Foo },
          bar: { model: $Foo, foreignKey: 'bazId' },
        };
      }
    });

    def('Foo', () => class Foo extends NextModel {
      static get modelName() {
        return 'Foo';
      }
    });

    it('prefills foreignKey if foreignKey is not present', function() {
      expect($subject).to.eql({
        foo: { model: $Foo, foreignKey: 'klassId' },
        bar: { model: $Foo, foreignKey: 'bazId' },
      });
    });
  });

  describe('.fetchHasOne()', function() {
    subject(() => $Klass.fetchHasOne());

    def('Klass', () => class Klass extends NextModel {
      static get modelName() {
        return 'Klass';
      }

      static get hasOne() {
        return {
          foo: { model: $Foo },
          bar: { model: $Foo, foreignKey: 'bazId' },
        };
      }
    });

    def('Foo', () => class Foo extends NextModel {
      static get modelName() {
        return 'Foo';
      }
    });

    it('prefills foreignKey if foreignKey is not present', function() {
      expect($subject).to.eql({
        foo: { model: $Foo, foreignKey: 'klassId' },
        bar: { model: $Foo, foreignKey: 'bazId' },
      });
    });
  });

  describe('.constructor', function() {
    subject(() => new $Klass($args));
    def('schema', () => ({}));
    def('belongsTo', () => ({}));
    def('hasMany', () => ({}));
    def('hasOne', () => ({}));

    def('Klass', () => class Klass extends NextModel {
      static get modelName() {
        return 'Klass';
      }

      static get schema() {
        return $schema;
      }

      static get belongsTo() {
        return $belongsTo;
      }

      static get hasMany() {
        return $hasMany;
      }

      static get hasOne() {
        return $hasOne;
      }

      static get attrAccessors() {
        return $attrAccessors;
      }
    });

    def('Foo', () => class Foo extends NextModel {
      static get modelName() {
        return 'Foo';
      }

      static get schema() {
        return {
          id: { type: 'integer' },
          klassId: { type: 'integer' },
        };
      }

      static get connector() {
        return mockConnector([
          { id: 1, klassId: 1 },
        ]);
      }
    });

    it('returns model instance', function() {
      expect($subject).to.be.a($Klass);
    });

    context('when schema is present', function() {
      def('schema', () => ({
        id: { type: 'integer' },
        bar: { type: 'string', defaultValue: 'bar' },
      }));

      it('returns model instance and sets default values', function() {
        expect($subject).to.be.a($Klass);
        expect($subject.id).to.eql(null);
        expect($subject.bar).to.eql('bar');
      });

      context('when passing attributes to constructor', function() {
        def('args', () => ({
          id: 1,
          bar: 'foo',
        }));

        it('returns model instance and sets attributes', function() {
          expect($subject).to.be.a($Klass);
          expect($subject.id).to.eql(1);
          expect($subject.bar).to.eql('foo');
        });

        context('when hasMany is present', function() {
          def('hasMany', () => ({
            foos: {model: $Foo},
          }));

          it('returns scope to foreign model', function() {
            expect($subject).to.be.a($Klass);
            expect($subject.foos).to.be.a('function');
            expect($subject.foos.defaultScope).to.eql({ klassId: 1 });
          });
        });

        context('when hasOne is present', function() {
          def('hasOne', () => ({
            foo: { model: $Foo },
          }));

          it('returns scope to foreign model', function() {
            expect($subject).to.be.a($Klass);
            return $subject.foo.then(data => {
              expect(data).to.be.a($Foo);
              expect(data.attributes).to.eql({ id: 1, klassId: 1 });
            });
          });
        });
      });

      context('when passing invalid attributes to constructor', function() {
        def('args', () => ({
          baz: 'foo',
        }));

        it('throws error while creating', function() {
          expect(() => $subject).to.throwError();
        });
      });

      context('when attrAccessors are present', function() {
        def('attrAccessors', () => ['baz']);

        it('does not set accessor', function() {
          expect($subject).to.be.a($Klass);
          expect($subject.baz).to.eql(undefined);
        });

        context('when passing attributes to constructor', function() {
          def('args', () => ({
            baz: 'foo',
          }));

          it('returns model instance and sets attributes', function() {
            expect($subject).to.be.a($Klass);
            expect($subject.baz).to.eql('foo');
          });
        });
      });
    });

    context('when belongsTo is present', function() {
      def('belongsTo', () => ({
        foo: { model: $Foo },
      }));

      it('returns model instance and applies default values to foreignKey', function() {
        expect($subject).to.be.a($Klass);
        expect($subject.fooId).to.eql(null);
      });

      context('when passing attributes to constructor', function() {
        def('args', () => ({
          fooId: 1,
        }));

        it('sets passed value', function() {
          expect($subject).to.be.a($Klass);
          expect($subject.fooId).to.eql(1);
        });
      });
    });
  });

  // Properties

  describe('#attributes', function() {
    subject(() => $klass.attributes);
    def('klass', () => new $Klass($args));
    def('args', () => ({}));
    def('attrAccessors', () => []);

    def('Klass', () => class Klass extends NextModel {
      static get modelName() {
        return 'Klass';
      }

      static get schema() {
        return {
          foo: { type: 'string' },
        };
      }

      static get attrAccessors() {
        return $attrAccessors;
      }
    });

    it('returns schema defined attributes', function() {
      expect($subject).to.eql({ foo: null });
    });

    context('when attribute is set', function() {
      def('args', () => ({ foo: 'bar' }));

      it('returns value', function() {
        expect($subject).to.eql({ foo: 'bar' });
      });
    });

    context('when unknown attribute is set', function() {
      beforeEach(function() {
        $klass.baz = 'foo';
      });

      it('ignores keys which are not in schema', function() {
        expect($subject).to.eql({ foo: null });
      });
    });

    context('when attrAccessors are present', function() {
      def('attrAccessors', () => ['bar']);
      def('args', () => ({ bar: 'foo' }));

      it('also returns keys from attrAccessors', function() {
        expect($subject).to.eql({ foo: null, bar: 'foo' });
      });
    });
  });

  describe('#databaseAttributes', function() {
    subject(() => $klass.databaseAttributes);
    def('klass', () => new $Klass($args));
    def('args', () => ({}));
    def('attrAccessors', () => []);

    def('Klass', () => class Klass extends NextModel {
      static get modelName() {
        return 'Klass';
      }

      static get identifier() {
        return $identifier;
      }

      static get schema() {
        return {
          foo: { type: 'string' },
        };
      }

      static get attrAccessors() {
        return $attrAccessors;
      }
    });

    it('returns schema defined attributes', function() {
      expect($subject).to.eql({ foo: null });
    });

    context('when attribute is set', function() {
      def('args', () => ({ foo: 'bar' }));

      it('returns value', function() {
        expect($subject).to.eql({ foo: 'bar' });
      });

      context('when identifier is present', function() {
        def('identifier', () => 'id');

        it('returns attributes of schema', function() {
          expect($subject).to.eql({ foo: 'bar' });
        });
      });

      context('when identifier is in schema', function() {
        def('identifier', () => 'foo');

        it('returns attributes without identifier', function() {
          expect($subject).to.eql({});
        });
      });
    });

    context('when unknown attribute is set', function() {
      beforeEach(function() {
        $klass.baz = 'foo';
      });

      it('ignores keys which are not in schema', function() {
        expect($subject).to.eql({ foo: null });
      });
    });

    context('when attrAccessors are present', function() {
      def('attrAccessors', () => ['bar']);
      def('args', () => ({ bar: 'foo' }));

      it('only returns attributes from schema', function() {
        expect($subject).to.eql({ foo: null});
      });
    });
  });

  describe('#isNew', function() {
    subject(() => $klass.isNew);

    def('Klass', () => class Klass extends NextModel {
      static get schema() {
        return {
          id: { type: 'integer' },
          foo: { type: 'string' },
        };
      }

      static get connector() {
        return { save: function(klass) {
          klass.id = 1;
          return Promise.resolve(true);
        }};
      }
    });

    def('klass', () => $Klass.build({foo: 'bar'}));

    context('when model is build', function() {
      it('returns true', function() {
        expect($subject).to.eql(true);
      });
    });

    context('when model is created', function() {
      beforeEach(function() {
        return $klass.save();
      });

      it('returns false', function() {
        expect($subject).to.eql(false);
      });
    });
  });

  describe('#isPersisted', function() {
    subject(() => $klass.isPersisted);

    def('Klass', () => class Klass extends NextModel {
      static get schema() {
        return {
          id: { type: 'integer' },
          foo: { type: 'string' },
        };
      }

      static get connector() {
        return { save: function(klass) {
          klass.id = 1;
          return Promise.resolve(true);
        }};
      }
    });

    def('klass', () => $Klass.build({foo: 'bar'}));

    context('when model is build', function() {
      it('returns false', function() {
        expect($subject).to.eql(false);
      });
    });

    context('when model is created', function() {
      beforeEach(function() {
        return $klass.save();
      });

      it('returns true', function() {
        expect($subject).to.eql(true);
      });
    });
  });

  // Functions

  describe('#assignAttribute()', function() {
    subject(() => $klass.assignAttribute($key, $value));
    def('klass', () => new $Klass($args));
    def('args', () => ({}));
    def('key', () => 'foo');
    def('value', () => 'bar');

    def('Klass', () => class Klass extends NextModel {
      static get modelName() {
        return 'Klass';
      }

      static get schema() {
        return {
          foo: { type: 'string' },
        };
      }
    });


    it('assigns values for keys from schema', function() {
      expect($klass.foo).to.eql(null);
      expect($subject.foo).to.eql('bar');
      expect($klass.foo).to.eql('bar');
    });

    context('when key is not in schema', function() {
      def('key', () => 'baz');

      it('throws error', function() {
        expect(() => $subject).to.throwError()
      });
    });


    context('when attribute is already set', function() {
      def('args', () => ({ foo: 'baz' }));

      it('overrides value', function() {
        expect($klass.foo).to.eql('baz');
        expect($subject.foo).to.eql('bar');
        expect($klass.foo).to.eql('bar');
      });
    });
  });

  describe('#assign()', function() {
    subject(() => $klass.assign({[$key]: $value}));
    def('klass', () => new $Klass($args));
    def('args', () => ({}));
    def('key', () => 'foo');
    def('value', () => 'bar');

    def('Klass', () => class Klass extends NextModel {
      static get modelName() {
        return 'Klass';
      }

      static get schema() {
        return {
          foo: { type: 'string' },
        };
      }
    });


    it('assigns values for keys from schema', function() {
      expect($klass.foo).to.eql(null);
      expect($subject.foo).to.eql('bar');
      expect($klass.foo).to.eql('bar');
    });

    context('when key is not in schema', function() {
      def('key', () => 'baz');

      it('throws error', function() {
        expect(() => $subject).to.throwError()
      });
    });


    context('when attribute is already set', function() {
      def('args', () => ({ foo: 'baz' }));

      it('overrides value', function() {
        expect($klass.foo).to.eql('baz');
        expect($subject.foo).to.eql('bar');
        expect($klass.foo).to.eql('bar');
      });
    });
  });

  describe('#save()', function() {
    subject(() => $klass.save());

    def('Klass', () => class Klass extends NextModel {
      static get schema() {
        return {
          id: { type: 'integer' },
          foo: { type: 'string' },
        };
      }

      static get connector() {
        return $connector;
      }
    });

    def('klass', () => $Klass.build());

    it('catches promise reject if connector is not overwritten', shared.promiseError);

    context('when connector is present', function() {
      def('connector', () => ({ save: function(klass) {
        klass.id = 1;
        return Promise.resolve(true);
      }}));

      it('saves the item', function() {
        expect($klass.id).to.eql(null);
        expect($klass.isNew).to.eql(true);
        return $subject.then(data => {
          expect(data).to.be.a($Klass);
          expect(data.id).to.eql(1);
          expect(data.isNew).to.eql(false);
        });
      });

      shared.behavesLikeActionWhichSupportsCallbacks({
        action: 'save',
        actionIsPromise: true,
      });
    });
  });

  describe('#delete()', function() {
    subject(() => $klass.delete());

    def('Klass', () => class Klass extends NextModel {
      static get schema() {
        return {
          id: { type: 'integer' },
          foo: { type: 'string' },
        };
      }

      static get connector() {
        return $connector;
      }
    });

    def('klass', () => $Klass.build());
    beforeEach(function() {
      $klass.id = 1;
    });

    it('catches promise reject if connector is not overwritten', shared.promiseError);

    context('when connector is present', function() {
      def('connector', () => ({ delete: function(klass) {
        delete klass.id;
        return Promise.resolve(true);
      }}));

      it('deletes the item', function() {
        expect($klass.isNew).to.eql(false);
        return $subject.then(data => {
          expect(data).to.be.a($Klass);
          expect(data.isNew).to.eql(true);
        });
      });

      context('when item is new', function() {
        beforeEach(function() {
          delete $klass.id;
        });

        it('does not change the item', function() {
          expect($klass.isNew).to.eql(true);
          return $subject.then(data => {
            expect(data).to.be.a($Klass);
            expect(data.isNew).to.eql(true);
          });
        });
      });

      shared.behavesLikeActionWhichSupportsCallbacks({
        action: 'delete',
        actionIsPromise: true,
      });
    });
  });

  describe('#reload()', function() {
    subject(() => $klass.reload());

    def('Klass', () => class Klass extends NextModel {
      static get schema() {
        return {
          id: { type: 'integer' },
          foo: { type: 'string' },
        };
      }

      static get connector() {
        return $connector;
      }
    });

    def('klass', () => {
      const klass = $Klass.build({ foo: 'foo' });
      klass.id = $id;
      return klass;
    });
    def('id', () => undefined);

    it('returns unchanged item as long as item is new', function() {
      return $subject.then(data => {
        expect(data).to.eql($klass);
      })
    });

    context('when item is persisted', function() {
      def('id', () => 1);

      it('throws error if connector is not overwritten', function() {
        expect(() => $subject).to.throwError();
      });

      context('when connector is present', function() {
        def('connector', () => mockConnector([$item]));

        context('when item is deleted', function() {
          def('item', () => undefined);

          it('flags item as new', function() {
            expect($klass.isNew).to.eql(false);

            return $subject.then(data => {
              expect(data).to.be.a($Klass);
              expect(data.isNew).to.eql(true);
              expect(data.foo).to.eql('foo');
            });
          });
        });

        context('when item is same', function() {
          def('item', () => $klass);

          it('does not change item', function() {
            return $subject.then(data => {
              expect(data).to.be.a($Klass);
              expect(data.id).to.eql($id);
              expect(data.foo).to.eql('foo');
            });
          });
        });

        context('when item has different values', function() {
          def('item', () => {
            const klass = $Klass.build({ foo: 'bar' });
            klass.id = $id;
            return klass;
          });

          it('updates values', function() {
            return $subject.then(data => {
              expect(data).to.be.a($Klass);
              expect(data.id).to.eql($id);
              expect(data.foo).to.eql('bar');
            });
          });
        });
      });
    });
  });
});
